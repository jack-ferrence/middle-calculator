<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Will’s Middling & Hedge Calculator</title>
  <style>
    :root{
      --bg:#0b0d12;
      --panel:#121622;
      --panel2:#0f1320;
      --text:#e9eefc;
      --muted:#a9b4d6;
      --line:#253052;
      --accent:#7aa2ff;
      --good:#48d18a;
      --bad:#ff5c74;
      --warn:#ffd166;
      --shadow: 0 12px 40px rgba(0,0,0,.35);
      --radius: 16px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 20% -10%, rgba(122,162,255,.18), transparent 55%),
                  radial-gradient(900px 700px at 90% 0%, rgba(72,209,138,.12), transparent 50%),
                  var(--bg);
      color:var(--text);
    }
    .wrap{max-width:1100px;margin:28px auto;padding:0 16px 56px}
    header{
      display:flex;align-items:flex-end;justify-content:space-between;gap:12px;margin-bottom:14px
    }
    h1{margin:0;font-size:22px;letter-spacing:.2px}
    .sub{margin:0;color:var(--muted);font-size:13px}
    .badge{
      border:1px solid var(--line);
      padding:10px 12px;border-radius:999px;
      background:rgba(18,22,34,.55);
      box-shadow: var(--shadow);
      font-size:12px;color:var(--muted);
      line-height:1.2;
      text-align:right;
      white-space:nowrap;
    }

    .stepper{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:10px;
      margin:16px 0 18px;
    }
    .step{
      border:1px solid var(--line);
      border-radius:14px;
      background:rgba(18,22,34,.6);
      box-shadow: var(--shadow);
      padding:12px 12px;
      display:flex;align-items:center;gap:10px;
    }
    .step .n{
      width:28px;height:28px;border-radius:10px;
      display:grid;place-items:center;
      border:1px solid var(--line);
      color:var(--muted);
      background:rgba(15,19,32,.65);
      font-weight:700;
    }
    .step.active{border-color:rgba(122,162,255,.55)}
    .step.active .n{border-color:rgba(122,162,255,.55);color:var(--text)}
    .step .t{display:flex;flex-direction:column}
    .step .t b{font-size:13px}
    .step .t span{font-size:12px;color:var(--muted)}

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
    }
    .panel{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(18,22,34,.78), rgba(15,19,32,.72));
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panelHeader{
      padding:14px 16px;
      border-bottom:1px solid rgba(37,48,82,.8);
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      background: rgba(15,19,32,.45);
    }
    .panelHeader .left{
      display:flex;align-items:baseline;gap:10px;flex-wrap:wrap
    }
    .panelHeader .k{
      font-size:12px;color:var(--muted);border:1px solid var(--line);
      padding:6px 10px;border-radius:999px;background:rgba(18,22,34,.35)
    }
    .panelHeader h2{margin:0;font-size:15px}
    .panelBody{padding:14px 16px 16px}

    .row{display:grid;grid-template-columns: repeat(12, 1fr);gap:10px;margin-bottom:10px}
    .field{grid-column: span 6}
    .field.small{grid-column: span 3}
    .field.tiny{grid-column: span 2}
    label{display:block;font-size:12px;color:var(--muted);margin:0 0 6px}
    input, select{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(37,48,82,.85);
      background: rgba(11,13,18,.65);
      color: var(--text);
      outline:none;
    }
    input:focus, select:focus{border-color:rgba(122,162,255,.7)}
    .help{font-size:12px;color:var(--muted);margin-top:6px;line-height:1.35}
    .divider{height:1px;background:rgba(37,48,82,.7);margin:12px 0}
    .btnRow{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    button{
      border:1px solid rgba(37,48,82,.85);
      background: rgba(18,22,34,.5);
      color: var(--text);
      padding:10px 12px;border-radius:12px;
      cursor:pointer;
    }
    button.primary{
      border-color:rgba(122,162,255,.65);
      background: rgba(122,162,255,.12);
    }
    button:active{transform: translateY(1px)}
    .note{
      padding:10px 12px;border-radius:12px;
      border:1px solid rgba(37,48,82,.85);
      background: rgba(15,19,32,.55);
      color:var(--muted);
      font-size:12px;
      line-height:1.4;
    }

    .resultsTop{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:12px;
      align-items:stretch;
    }
    @media (max-width: 900px){
      .resultsTop{grid-template-columns:1fr}
      .field.small,.field.tiny,.field{grid-column: span 12}
      .stepper{grid-template-columns:1fr;gap:8px}
    }

    .bigBox{
      border:1px solid rgba(37,48,82,.9);
      background: rgba(11,13,18,.55);
      border-radius:16px;
      padding:14px 14px;
      box-shadow: var(--shadow);
    }
    .bigTitle{display:flex;justify-content:space-between;gap:10px;align-items:flex-start}
    .bigTitle h3{margin:0;font-size:14px;color:var(--muted);font-weight:600}
    .bigTitle .right{font-size:12px;color:var(--muted);text-align:right}
    .bigNum{
      font-size:34px;
      margin:10px 0 0;
      letter-spacing:.2px;
      font-weight:800;
    }
    .bigSub{margin:6px 0 0;font-size:12px;color:var(--muted)}
    .pos{color:var(--good)}
    .neg{color:var(--bad)}
    .mid{color:var(--warn)}

    .tableWrap{
      border:1px solid rgba(37,48,82,.9);
      background: rgba(11,13,18,.42);
      border-radius:16px;
      overflow:hidden;
    }
    table{width:100%;border-collapse:collapse;font-size:13px}
    thead th{
      text-align:left;
      padding:10px 12px;
      background: rgba(15,19,32,.7);
      border-bottom:1px solid rgba(37,48,82,.9);
      color: var(--muted);
      font-weight:600;
    }
    tbody td{
      padding:10px 12px;
      border-bottom:1px solid rgba(37,48,82,.55);
      vertical-align:top;
    }
    tbody tr:last-child td{border-bottom:none}
    .pill{
      display:inline-block;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(37,48,82,.85);
      color:var(--muted);
      font-size:12px;
      background: rgba(18,22,34,.35);
    }
    .mono{font-variant-numeric: tabular-nums; font-feature-settings:"tnum" 1}
    .muted{color:var(--muted)}
    .warnText{color:var(--warn)}
    .goodText{color:var(--good)}
    .badText{color:var(--bad)}

    .sliderBox{
      border:1px solid rgba(37,48,82,.9);
      background: rgba(11,13,18,.42);
      border-radius:16px;
      padding:14px 14px;
    }
    input[type="range"]{width:100%}
    .miniGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .mini{
      border:1px solid rgba(37,48,82,.75);
      background: rgba(15,19,32,.55);
      border-radius:14px;
      padding:10px 12px;
    }
    .mini h4{margin:0 0 6px;font-size:12px;color:var(--muted);font-weight:600}
    .mini .v{font-size:18px;font-weight:800}
    .footerNote{margin-top:10px;font-size:12px;color:var(--muted);line-height:1.35}
    .hidden{display:none}
  
    /* --- Gift photo decorations (non-destructive) --- */
    .giftTop, .giftBottom{
      width: min(1100px, 100%);
      margin: 18px auto;
      padding: 0 16px;
      box-sizing: border-box;
    }
    .giftTop img, .giftBottom img{
      display:block;
      width:100%;
      height:auto;
      object-fit:contain;
      border-radius: 18px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.15);
    }

    /* Side "popup ad" style, but never crop the image */
    .sideAd{
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
      z-index: 999;
      width: 220px;
      padding: 10px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(10,12,22,.72);
      box-shadow: var(--shadow);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    .sideAd.left{ left: 10px; }
    .sideAd.right{ right: 10px; }
    .sideAd img{
      display:block;
      width:100%;
      height:auto;
      max-height: 82vh;
      object-fit: contain;
      border-radius: 12px;
    }
    @media (max-width: 1200px){
      .sideAd{ display:none; }
    }
    @media (min-width: 1201px){
      body{ padding-left: 250px; padding-right: 250px; }
      .wrap{ margin: 28px auto; }
    }
    
  </style>
</head>
<body>
  <!-- Gift photo decorations -->
  <div class="giftTop">
    <img src="top%20photo.png" alt="Will’s Middling & Hedging Calculator - Top Banner" loading="eager" decoding="async"/>
  </div>

  <div class="sideAd left" aria-hidden="true">
    <img src="photo%201.png" alt="Gift photo left" loading="lazy" decoding="async"/>
  </div>
  <div class="sideAd right" aria-hidden="true">
    <img src="photo%202.png" alt="Gift photo right" loading="lazy" decoding="async"/>
  </div>

  <div class="wrap">
    <header>
      <div>
        <h1>Will’s Middling & Hedge Calculator</h1>
        <p class="sub">Fast payout math for live middles and hedges (neutral calculator).</p>
      </div>
      <div class="badge">
        Default unit: <b>$20</b><br/>
        Live odds drift: <b>±15</b>
      </div>
    </header>

    <div class="stepper" id="stepper">
      <div class="step active" data-step="1">
        <div class="n">1</div>
        <div class="t"><b>Setup</b><span>League + teams</span></div>
      </div>
      <div class="step" data-step="2">
        <div class="n">2</div>
        <div class="t"><b>Pregame</b><span>Original bet</span></div>
      </div>
      <div class="step" data-step="3">
        <div class="n">3</div>
        <div class="t"><b>Live</b><span>Middle / hedge</span></div>
      </div>
      <div class="step" data-step="4">
        <div class="n">4</div>
        <div class="t"><b>Results</b><span>Slider + payouts</span></div>
      </div>
    </div>

    <div class="grid">
      <!-- Panel 1 -->
      <section class="panel" id="panel1">
        <div class="panelHeader">
          <div class="left">
            <span class="k">Panel 1</span>
            <h2>Setup (league + teams)</h2>
          </div>
          <div class="btnRow">
            <button class="primary" id="to2a" type="button">Go to Panel 2 →</button>
          </div>
        </div>
        <div class="panelBody">
          <div class="row">
            <div class="field small">
              <label for="league">League</label>
              <select id="league">
                <option value="NFL">NFL</option>
                <option value="NBA">NBA</option>
              </select>
              <div class="help">Team dropdowns load the full league list. Defaults stay “Team A / Team B” if you don’t pick.</div>
            </div>
            <div class="field">
              <label for="teamA">Team A</label>
              <select id="teamA"></select>
            </div>
            <div class="field">
              <label for="teamB">Team B</label>
              <select id="teamB"></select>
            </div>
          </div>

          <div class="note">
            Middle logic assumes the two bets are on opposite sides (ex: A -3.5 pregame, B +7.5 live; or Over 45.5 pregame, Under 52.5 live).
            Moneyline has no true “middle” range; it’s a hedge outcome split.
          </div>
        </div>
      </section>

      <!-- Panel 2 -->
      <section class="panel" id="panel2">
        <div class="panelHeader">
          <div class="left">
            <span class="k">Panel 2</span>
            <h2>Pregame bet (original)</h2>
          </div>
          <div class="btnRow">
            <button id="back1a" type="button">← Back to Panel 1</button>
            <button class="primary" id="to3a" type="button">Go to Panel 3 →</button>
          </div>
        </div>
        <div class="panelBody">
          <div class="row">
            <div class="field small">
              <label for="betType">Bet type</label>
              <select id="betType">
                <option value="SPREAD">Spread</option>
                <option value="TOTAL">Total (O/U)</option>
                <option value="ML">Moneyline</option>
              </select>
            </div>

            <div class="field small" id="pregameSideWrap">
              <label for="pregameSide">Pregame side</label>
              <select id="pregameSide">
                <option value="A">Team A</option>
                <option value="B">Team B</option>
                <option value="OVER">Over</option>
                <option value="UNDER">Under</option>
              </select>
            </div>

            <div class="field small" id="pregameLineWrap">
              <label for="pregameLine">Pregame line</label>
              <input id="pregameLine" type="number" step="0.5" value="-3.5" />
              <div class="help">Spread example: -3.5. Total example: 45.5. Moneyline: ignored.</div>
            </div>

            <div class="field small">
              <label for="pregameOdds">Pregame odds (American)</label>
              <input id="pregameOdds" type="number" step="1" value="-110" />
            </div>

            <div class="field small">
              <label for="pregameStake">Pregame stake ($)</label>
              <input id="pregameStake" type="number" step="1" value="20" />
            </div>
          </div>

          <div class="divider"></div>

          <div class="note">
            Interpretation:
            <span class="pill">Spread</span> pregame side is Team A or Team B with a line.
            <span class="pill">Total</span> pregame side is Over or Under with a total.
            <span class="pill">Moneyline</span> pregame side is Team A or Team B; line is ignored.
          </div>
        </div>
      </section>

      <!-- Panel 3 -->
      <section class="panel" id="panel3">
        <div class="panelHeader">
          <div class="left">
            <span class="k">Panel 3</span>
            <h2>Live bet (middle / hedge leg)</h2>
          </div>
          <div class="btnRow">
            <button id="back2a" type="button">← Back to Panel 2</button>
            <button class="primary" id="to4a" type="button">Go to Panel 4 →</button>
          </div>
        </div>
        <div class="panelBody">
          <div class="row">
            <div class="field small" id="liveSideWrap">
              <label for="liveSide">Live side</label>
              <select id="liveSide">
                <option value="A">Team A</option>
                <option value="B">Team B</option>
                <option value="OVER">Over</option>
                <option value="UNDER">Under</option>
              </select>
            </div>

            <div class="field small" id="liveLineWrap">
              <label for="liveLine">Live line</label>
              <input id="liveLine" type="number" step="0.5" value="7.5" />
            </div>

            <div class="field small">
              <label for="liveOdds">Live odds (American)</label>
              <input id="liveOdds" type="number" step="1" value="-110" />
              <div class="help">Displayed payout also shows a ±15 odds drift range.</div>
            </div>

            <div class="field small">
              <label for="liveStake">Live stake default ($)</label>
              <input id="liveStake" type="number" step="1" value="20" />
              <div class="help">This sets the slider’s starting value.</div>
            </div>

            <div class="field small">
              <label for="sliderMax">Slider max ($)</label>
              <input id="sliderMax" type="number" step="10" value="300" />
            </div>
          </div>

          <div class="note">
            For a “classic middle” in spreads/totals you need a gap:
            pregame side wins on one side of the gap, live side wins on the other side, and the middle zone is where both win.
          </div>
        </div>
      </section>

      <!-- Panel 4 -->
      <section class="panel" id="panel4">
        <div class="panelHeader">
          <div class="left">
            <span class="k">Panel 4</span>
            <h2>Results (slider + payout layout)</h2>
          </div>
          <div class="btnRow">
            <button id="back3a" type="button">← Back to Panel 3</button>
            <button id="reset" type="button">Reset to defaults</button>
          </div>
        </div>
        <div class="panelBody">

          <div class="resultsTop">
            <div class="bigBox">
              <div class="bigTitle">
                <div>
                  <h3>Headline: Net profit for selected outcome</h3>
                  <div class="bigSub muted" id="headlineContext">Move the live stake slider. Tables update live.</div>
                </div>
                <div class="right">
                  <div class="pill" id="teamsLabel">Team A vs Team B</div><br/>
                  <span class="mono muted" id="betSummary">—</span>
                </div>
              </div>
              <div class="bigNum mono" id="headlineNet">$0.00</div>
              <div class="bigSub" id="headlineRange">(range: $0.00 to $0.00 if live odds drift ±15)</div>
            </div>

            <div class="sliderBox">
              <label for="stakeSlider">Live stake ($)</label>
              <input id="stakeSlider" type="range" min="0" max="300" step="1" value="20" />
              <div class="miniGrid">
                <div class="mini">
                  <h4>Live stake</h4>
                  <div class="v mono" id="liveStakeRead">$20</div>
                  <div class="help">Adjusting this is the whole point: find the stake that makes the middle/hedge worth it.</div>
                </div>
                <div class="mini">
                  <h4>Middle size (if any)</h4>
                  <div class="v mono" id="middleSize">—</div>
                  <div class="help">Spread: winning margin integers. Total: total-points integers.</div>
                </div>
              </div>
              <div class="footerNote" id="noMiddleNote"></div>
            </div>
          </div>

          <div class="divider"></div>

          <div class="tableWrap">
            <table>
              <thead>
                <tr>
                  <th>Outcome bucket</th>
                  <th>What happens</th>
                  <th>Net profit (entered live odds)</th>
                  <th>Net profit range (live odds ±15)</th>
                </tr>
              </thead>
              <tbody id="bucketRows"></tbody>
            </table>
          </div>

          <div class="divider"></div>

          <div class="tableWrap" id="middleTableWrap">
            <table>
              <thead>
                <tr>
                  <th>Middle zone detail</th>
                  <th>Exact results that “double-win”</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td class="muted">If there is a middle, this lists the integers inside the gap.</td>
                  <td class="mono" id="middleDetail">—</td>
                </tr>
              </tbody>
            </table>
          </div>

        </div>
      </section>

    </div>
  </div>

<script>
/* =========================
   League data
========================= */
const LEAGUES = {
  NFL: [
    "Arizona Cardinals","Atlanta Falcons","Baltimore Ravens","Buffalo Bills","Carolina Panthers","Chicago Bears",
    "Cincinnati Bengals","Cleveland Browns","Dallas Cowboys","Denver Broncos","Detroit Lions","Green Bay Packers",
    "Houston Texans","Indianapolis Colts","Jacksonville Jaguars","Kansas City Chiefs","Las Vegas Raiders","Los Angeles Chargers",
    "Los Angeles Rams","Miami Dolphins","Minnesota Vikings","New England Patriots","New Orleans Saints","New York Giants",
    "New York Jets","Philadelphia Eagles","Pittsburgh Steelers","San Francisco 49ers","Seattle Seahawks","Tampa Bay Buccaneers",
    "Tennessee Titans","Washington Commanders"
  ],
  NBA: [
    "Atlanta Hawks","Boston Celtics","Brooklyn Nets","Charlotte Hornets","Chicago Bulls","Cleveland Cavaliers",
    "Dallas Mavericks","Denver Nuggets","Detroit Pistons","Golden State Warriors","Houston Rockets","Indiana Pacers",
    "LA Clippers","Los Angeles Lakers","Memphis Grizzlies","Miami Heat","Milwaukee Bucks","Minnesota Timberwolves",
    "New Orleans Pelicans","New York Knicks","Oklahoma City Thunder","Orlando Magic","Philadelphia 76ers","Phoenix Suns",
    "Portland Trail Blazers","Sacramento Kings","San Antonio Spurs","Toronto Raptors","Utah Jazz","Washington Wizards"
  ]
};

/* =========================
   Helpers: formatting + odds math
========================= */
const fmtMoney = (n) => {
  const v = Number.isFinite(n) ? n : 0;
  const sign = v < 0 ? "-" : "";
  const abs = Math.abs(v);
  return `${sign}$${abs.toFixed(2)}`;
};
const clamp = (x,min,max) => Math.max(min, Math.min(max, x));

function americanProfit(stake, odds){
  stake = Number(stake) || 0;
  odds = Number(odds) || 0;
  if (odds === 0) return 0;
  if (odds > 0) return stake * (odds/100);
  return stake * (100/Math.abs(odds));
}
function americanPayoutTotal(stake, odds){
  return stake + americanProfit(stake, odds);
}
function driftOddsRange(odds){
  const o = Number(odds) || 0;
  if (o === 0) return {min:0,max:0};
  const min = o - 15;
  const max = o + 15;
  return {min, max};
}
function profitRangeForWin(stake, odds){
  const r = driftOddsRange(odds);
  const p1 = americanProfit(stake, r.min);
  const p2 = americanProfit(stake, r.max);
  return {min: Math.min(p1,p2), max: Math.max(p1,p2), oddsMin:r.min, oddsMax:r.max};
}

/* =========================
   Bet resolution logic
========================= */
function resolveSpread(side, line, margin){
  // margin = TeamA score - TeamB score
  // side: "A" or "B"
  line = Number(line);
  margin = Number(margin);
  if (!Number.isFinite(line) || !Number.isFinite(margin)) return "LOSE";

  if (side === "A"){
    const adj = margin + line; // if line is -3.5, needs margin -3.5? Actually A -3.5 means margin-3.5 > 0 => margin > 3.5
    if (adj > 0) return "WIN";
    if (adj === 0) return "PUSH";
    return "LOSE";
  } else {
    // B line is typically positive if B is dog. Equivalent: (-margin) + line > 0
    const adj = (-margin) + line;
    if (adj > 0) return "WIN";
    if (adj === 0) return "PUSH";
    return "LOSE";
  }
}
function resolveTotal(side, line, totalPoints){
  line = Number(line);
  totalPoints = Number(totalPoints);
  if (!Number.isFinite(line) || !Number.isFinite(totalPoints)) return "LOSE";

  if (side === "OVER"){
    if (totalPoints > line) return "WIN";
    if (totalPoints === line) return "PUSH";
    return "LOSE";
  } else {
    if (totalPoints < line) return "WIN";
    if (totalPoints === line) return "PUSH";
    return "LOSE";
  }
}
function resolveML(side, winner){
  // winner: "A" or "B"
  return (side === winner) ? "WIN" : "LOSE";
}

function betWinProfit(stake, odds){
  return americanProfit(stake, odds);
}

/* =========================
   UI state + wiring
========================= */
const els = {
  league: document.getElementById("league"),
  teamA: document.getElementById("teamA"),
  teamB: document.getElementById("teamB"),

  betType: document.getElementById("betType"),
  pregameSide: document.getElementById("pregameSide"),
  pregameLine: document.getElementById("pregameLine"),
  pregameOdds: document.getElementById("pregameOdds"),
  pregameStake: document.getElementById("pregameStake"),

  liveSide: document.getElementById("liveSide"),
  liveLine: document.getElementById("liveLine"),
  liveOdds: document.getElementById("liveOdds"),
  liveStake: document.getElementById("liveStake"),
  sliderMax: document.getElementById("sliderMax"),

  stakeSlider: document.getElementById("stakeSlider"),
  liveStakeRead: document.getElementById("liveStakeRead"),

  teamsLabel: document.getElementById("teamsLabel"),
  betSummary: document.getElementById("betSummary"),

  headlineNet: document.getElementById("headlineNet"),
  headlineRange: document.getElementById("headlineRange"),
  headlineContext: document.getElementById("headlineContext"),

  bucketRows: document.getElementById("bucketRows"),
  middleSize: document.getElementById("middleSize"),
  noMiddleNote: document.getElementById("noMiddleNote"),
  middleDetail: document.getElementById("middleDetail"),
  middleTableWrap: document.getElementById("middleTableWrap"),

  pregameSideWrap: document.getElementById("pregameSideWrap"),
  pregameLineWrap: document.getElementById("pregameLineWrap"),
  liveSideWrap: document.getElementById("liveSideWrap"),
  liveLineWrap: document.getElementById("liveLineWrap"),

  // nav buttons
  to2a: document.getElementById("to2a"),
  to3a: document.getElementById("to3a"),
  to4a: document.getElementById("to4a"),
  back1a: document.getElementById("back1a"),
  back2a: document.getElementById("back2a"),
  back3a: document.getElementById("back3a"),
  reset: document.getElementById("reset"),

  panel1: document.getElementById("panel1"),
  panel2: document.getElementById("panel2"),
  panel3: document.getElementById("panel3"),
  panel4: document.getElementById("panel4"),
  stepper: document.getElementById("stepper"),
};

function setStepper(active){
  [...els.stepper.querySelectorAll(".step")].forEach(s=>{
    s.classList.toggle("active", Number(s.dataset.step) === active);
  });
}
function scrollToPanel(panelEl){ /* no auto-scroll */ }

function populateTeams(){
  const league = els.league.value;
  const list = LEAGUES[league] || [];
  const makeOptions = (selectEl, defaultLabel) => {
    selectEl.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = defaultLabel;
    opt0.textContent = defaultLabel;
    selectEl.appendChild(opt0);
    list.forEach(name=>{
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      selectEl.appendChild(opt);
    });
  };
  makeOptions(els.teamA, "Team A");
  makeOptions(els.teamB, "Team B");
  updateLabels();
}

function updateLabels(){
  const a = els.teamA.value || "Team A";
  const b = els.teamB.value || "Team B";
  els.teamsLabel.textContent = `${a} vs ${b}`;
  updateSideSelectors();
  updateAll();
}

function updateSideSelectors(){
  const type = els.betType.value;
  const a = els.teamA.value || "Team A";
  const b = els.teamB.value || "Team B";

  // rebuild side options to show names while preserving values
  const setSelect = (sel, items) => {
    const cur = sel.value;
    sel.innerHTML = "";
    items.forEach(([val,label])=>{
      const o = document.createElement("option");
      o.value = val;
      o.textContent = label;
      sel.appendChild(o);
    });
    // best effort restore
    const canRestore = [...sel.options].some(o=>o.value===cur);
    if (canRestore) sel.value = cur;
  };

  if (type === "SPREAD" || type === "ML"){
    setSelect(els.pregameSide, [["A",a],["B",b]]);
    setSelect(els.liveSide, [["A",a],["B",b]]);
  } else {
    setSelect(els.pregameSide, [["OVER","Over"],["UNDER","Under"]]);
    setSelect(els.liveSide, [["OVER","Over"],["UNDER","Under"]]);
  }

  // show/hide line boxes
  const showLine = (type === "SPREAD" || type === "TOTAL");
  els.pregameLineWrap.classList.toggle("hidden", !showLine);
  els.liveLineWrap.classList.toggle("hidden", !showLine);
}

function resetDefaults(){
  els.league.value = "NFL";
  populateTeams();

  els.betType.value = "SPREAD";
  els.pregameLine.value = -3.5;
  els.pregameOdds.value = -110;
  els.pregameStake.value = 20;

  els.liveLine.value = 7.5;
  els.liveOdds.value = -110;
  els.liveStake.value = 20;
  els.sliderMax.value = 300;

  updateSideSelectors();
  syncSliderFromInputs();
  updateAll();
}

function syncSliderFromInputs(){
  const max = Math.max(0, Number(els.sliderMax.value) || 300);
  els.stakeSlider.max = String(max);
  const start = clamp(Number(els.liveStake.value) || 20, 0, max);
  els.stakeSlider.value = String(start);
  els.liveStakeRead.textContent = `$${Number(els.stakeSlider.value).toFixed(0)}`;
}

/* =========================
   Computation + rendering
========================= */
function classForMoney(v){
  if (v > 0.0001) return "pos";
  if (v < -0.0001) return "neg";
  return "mid";
}
function makeBetSummary(){
  const type = els.betType.value;
  const a = els.teamA.value || "Team A";
  const b = els.teamB.value || "Team B";
  const preSide = els.pregameSide.value;
  const preLine = Number(els.pregameLine.value);
  const preOdds = Number(els.pregameOdds.value);
  const preStake = Number(els.pregameStake.value);

  const liveSide = els.liveSide.value;
  const liveLine = Number(els.liveLine.value);
  const liveOdds = Number(els.liveOdds.value);

  const sideLabel = (s)=>{
    if (type === "SPREAD" || type === "ML"){
      return (s === "A") ? a : b;
    }
    return (s === "OVER") ? "Over" : "Under";
  };

  if (type === "ML"){
    return `${type}: Pregame ${sideLabel(preSide)} @ ${preOdds} for $${preStake.toFixed(0)} | Live ${sideLabel(liveSide)} @ ${liveOdds}`;
  }
  const lineLabel = (type === "SPREAD")
    ? `${sideLabel(preSide)} ${preLine}`
    : `${sideLabel(preSide)} ${preLine}`;
  const lineLabel2 = (type === "SPREAD")
    ? `${sideLabel(liveSide)} ${liveLine}`
    : `${sideLabel(liveSide)} ${liveLine}`;
  return `${type}: Pregame ${lineLabel} @ ${preOdds} for $${preStake.toFixed(0)} | Live ${lineLabel2} @ ${liveOdds}`;
}

function computeNetForScenario(outcomeKey, liveStakeValue, liveOddsOverride=null){
  // outcomeKey depends on bet type:
  // SPREAD: "PREGAME_WINS", "LIVE_WINS", "MIDDLE", "DOUBLE_LOSE", "PUSH_CASE"
  // TOTAL: same buckets
  // ML: "A_WINS" or "B_WINS"

  const type = els.betType.value;

  const preStake = Number(els.pregameStake.value) || 0;
  const preOdds = Number(els.pregameOdds.value) || 0;
  const preSide = els.pregameSide.value;
  const preLine = Number(els.pregameLine.value);

  const liveStake = Number(liveStakeValue) || 0;
  const liveOdds = (liveOddsOverride !== null) ? Number(liveOddsOverride) : (Number(els.liveOdds.value) || 0);
  const liveSide = els.liveSide.value;
  const liveLine = Number(els.liveLine.value);

  const preWin = betWinProfit(preStake, preOdds);
  const liveWin = betWinProfit(liveStake, liveOdds);

  // Default: lose means -stake; push means 0
  function netFromResults(preRes, liveRes){
    let net = 0;
    // pregame
    if (preRes === "WIN") net += preWin;
    else if (preRes === "LOSE") net -= preStake;
    else net += 0;

    // live
    if (liveRes === "WIN") net += liveWin;
    else if (liveRes === "LOSE") net -= liveStake;
    else net += 0;

    return net;
  }

  if (type === "ML"){
    const winner = outcomeKey; // "A" or "B"
    const preRes = resolveML(preSide, winner);
    const liveRes = resolveML(liveSide, winner);
    return netFromResults(preRes, liveRes);
  }

  // SPREAD/TOTAL buckets mapped to abstract results
  if (outcomeKey === "MIDDLE"){
    return netFromResults("WIN","WIN");
  }
  if (outcomeKey === "PREGAME_WINS"){
    return netFromResults("WIN","LOSE");
  }
  if (outcomeKey === "LIVE_WINS"){
    return netFromResults("LOSE","WIN");
  }
  if (outcomeKey === "DOUBLE_LOSE"){
    return netFromResults("LOSE","LOSE");
  }
  if (outcomeKey === "PUSH_CASE"){
    // one or both push; treat as 0 for pushes. Use a neutral representative: pre PUSH, live LOSE
    return netFromResults("PUSH","LOSE");
  }

  return 0;
}

function computeMiddleInfo(){
  const type = els.betType.value;
  if (type === "ML"){
    return {hasMiddle:false, size:0, detail:"—", note:"Moneyline has no middle range. Use it as a hedge split."};
  }

  const preSide = els.pregameSide.value;
  const liveSide = els.liveSide.value;
  const preLine = Number(els.pregameLine.value);
  const liveLine = Number(els.liveLine.value);

  if (!Number.isFinite(preLine) || !Number.isFinite(liveLine)){
    return {hasMiddle:false, size:0, detail:"—", note:"Enter valid lines to compute a middle range."};
  }

  // Needs opposite sides to create a gap:
  // SPREAD: pre on A and live on B (or vice versa)
  // TOTAL: pre OVER live UNDER (or vice versa)
  if (type === "SPREAD"){
    if (preSide === liveSide){
      return {hasMiddle:false, size:0, detail:"—", note:"Same-side spread bets do not create a middle. This is a hedge-only layout."};
    }

    // Determine winning-margin integers where both win:
    // Suppose pre is A with line L1 (ex -3.5). Condition: margin + L1 > 0  => margin > -L1
    // live is B with line L2 (ex +7.5). Condition: (-margin) + L2 > 0 => margin < L2
    // So middle: -L1 < margin < L2 (open interval; pushes excluded)
    // If swapped sides, symmetric:
    // pre B line L1 => margin < L1
    // live A line L2 => margin > -L2
    // middle: -L2 < margin < L1
    let lowOpen, highOpen;

    if (preSide === "A" && liveSide === "B"){
      lowOpen = -preLine;
      highOpen = liveLine;
    } else if (preSide === "B" && liveSide === "A"){
      lowOpen = -liveLine;
      highOpen = preLine;
    } else {
      return {hasMiddle:false, size:0, detail:"—", note:"Unrecognized spread side mapping."};
    }

    const lo = Math.min(lowOpen, highOpen);
    const hi = Math.max(lowOpen, highOpen);

    // Need lo < hi to have any gap; and middle integers are those strictly between.
    const ints = [];
    for (let m = Math.ceil(lo + 1e-9); m <= Math.floor(hi - 1e-9); m++){
      // exclude values that would push either bet (exact equals boundary)
      if (m > lo && m < hi) ints.push(m);
    }

    if (ints.length === 0){
      return {hasMiddle:false, size:0, detail:"—", note:"No middle gap. You can still use the slider to build a hedge profile."};
    }

    return {hasMiddle:true, size:ints.length, detail:ints.join(", "), note:""};
  }

  if (type === "TOTAL"){
    if (preSide === liveSide){
      return {hasMiddle:false, size:0, detail:"—", note:"Same-side totals do not create a middle. This is a hedge-only layout."};
    }

    // Both win only if one is OVER at lower number and the other is UNDER at higher number.
    // Example: Over 45.5 and Under 52.5 => middle totals: 46..52 integers.
    let overLine, underLine;
    if (preSide === "OVER" && liveSide === "UNDER"){
      overLine = preLine;
      underLine = liveLine;
    } else if (preSide === "UNDER" && liveSide === "OVER"){
      overLine = liveLine;
      underLine = preLine;
    } else {
      return {hasMiddle:false, size:0, detail:"—", note:"Unrecognized total side mapping."};
    }

    const lo = Math.min(overLine, underLine);
    const hi = Math.max(overLine, underLine);

    // Need overLine < underLine for a middle
    if (!(overLine < underLine)){
      return {hasMiddle:false, size:0, detail:"—", note:"No middle gap. You can still hedge outcomes."};
    }

    const ints = [];
    for (let t = Math.ceil(lo + 1e-9); t <= Math.floor(hi - 1e-9); t++){
      if (t > lo && t < hi) ints.push(t);
    }

    if (ints.length === 0){
      return {hasMiddle:false, size:0, detail:"—", note:"No middle gap. You can still hedge outcomes."};
    }

    return {hasMiddle:true, size:ints.length, detail:ints.join(", "), note:""};
  }

  return {hasMiddle:false, size:0, detail:"—", note:""};
}

function render(){
  const type = els.betType.value;
  const liveStake = Number(els.stakeSlider.value) || 0;
  els.liveStakeRead.textContent = `$${liveStake.toFixed(0)}`;
  els.betSummary.textContent = makeBetSummary();

  const a = els.teamA.value || "Team A";
  const b = els.teamB.value || "Team B";

  const midInfo = computeMiddleInfo();
  els.middleSize.textContent = midInfo.hasMiddle ? `${midInfo.size}` : "—";
  els.noMiddleNote.textContent = midInfo.note || "";
  els.middleDetail.textContent = midInfo.hasMiddle ? midInfo.detail : "—";
  els.middleTableWrap.classList.toggle("hidden", !midInfo.hasMiddle);

  // compute headline: pick the “best” bucket (middle if exists, otherwise pregame wins for same-side?).
  let headlineBucket;
  if (type === "ML"){
    headlineBucket = "A"; // display A wins as headline reference
    els.headlineContext.textContent = "Headline shown for: Team A wins. Table shows both win-sides.";
  } else if (midInfo.hasMiddle){
    headlineBucket = "MIDDLE";
    els.headlineContext.textContent = "Headline shown for: middle zone (both bets win). Table shows all buckets.";
  } else {
    headlineBucket = "PREGAME_WINS";
    els.headlineContext.textContent = "Headline shown for: pregame bet wins (live bet loses). Table shows all buckets.";
  }

  // headline net at entered live odds
  const headlineNet = computeNetForScenario(headlineBucket, liveStake);

  // headline range with odds drift ±15 (live odds only)
  const o = Number(els.liveOdds.value) || 0;
  const r = driftOddsRange(o);
  const n1 = computeNetForScenario(headlineBucket, liveStake, r.min);
  const n2 = computeNetForScenario(headlineBucket, liveStake, r.max);
  const minN = Math.min(n1,n2);
  const maxN = Math.max(n1,n2);

  els.headlineNet.textContent = fmtMoney(headlineNet);
  els.headlineNet.className = `bigNum mono ${classForMoney(headlineNet)}`;
  els.headlineRange.textContent = `(range: ${fmtMoney(minN)} to ${fmtMoney(maxN)} if live odds drift ±15)`;

  // render bucket table
  els.bucketRows.innerHTML = "";

  if (type === "ML"){
    const rows = [
      {
        key: "A",
        label: `${a} wins`,
        desc: `Pregame ${sideNameML(els.pregameSide.value,a,b)} vs Live ${sideNameML(els.liveSide.value,a,b)} resolves to the winner.`,
      },
      {
        key: "B",
        label: `${b} wins`,
        desc: `Same stakes/odds, opposite winner.`,
      }
    ];
    rows.forEach(row=>{
      const net = computeNetForScenario(row.key, liveStake);
      const nMin = computeNetForScenario(row.key, liveStake, r.min);
      const nMax = computeNetForScenario(row.key, liveStake, r.max);
      addBucketRow(row.label, row.desc, net, Math.min(nMin,nMax), Math.max(nMin,nMax));
    });
    return;
  }

  // SPREAD/TOTAL buckets
  const buckets = [];

  if (midInfo.hasMiddle){
    buckets.push({
      key:"MIDDLE",
      label:"Middle zone (double win)",
      desc:"Both bets win inside the gap."
    });
  }
  buckets.push({
    key:"PREGAME_WINS",
    label:"Pregame wins / Live loses",
    desc:"Game lands on the pregame side beyond the gap (or if no gap: the pregame side outcome)."
  });
  buckets.push({
    key:"LIVE_WINS",
    label:"Live wins / Pregame loses",
    desc:"Game lands on the live side beyond the gap (or if no gap: the live side outcome)."
  });
  buckets.push({
    key:"DOUBLE_LOSE",
    label:"Both lose (worst case)",
    desc:"If bets are mis-aligned (no gap) you can create a zone where both lose. This row shows that maximum damage scenario."
  });

  // push note
  buckets.push({
    key:"PUSH_CASE",
    label:"Push edge case",
    desc:"If a line is a whole number and the result hits exactly, that leg can push (treated as 0 profit/loss)."
  });

  buckets.forEach(b=>{
    const net = computeNetForScenario(b.key, liveStake);
    const nMin = computeNetForScenario(b.key, liveStake, r.min);
    const nMax = computeNetForScenario(b.key, liveStake, r.max);
    addBucketRow(b.label, b.desc, net, Math.min(nMin,nMax), Math.max(nMin,nMax));
  });
}

function sideNameML(val,a,b){
  return (val==="A") ? a : b;
}

function addBucketRow(label, desc, net, netMin, netMax){
  const tr = document.createElement("tr");
  const td1 = document.createElement("td");
  const td2 = document.createElement("td");
  const td3 = document.createElement("td");
  const td4 = document.createElement("td");

  td1.innerHTML = `<b>${label}</b>`;
  td2.innerHTML = `<span class="muted">${desc}</span>`;
  td3.innerHTML = `<span class="mono ${classForMoney(net)}"><b>${fmtMoney(net)}</b></span>`;
  td4.innerHTML = `<span class="mono muted">${fmtMoney(netMin)} to ${fmtMoney(netMax)}</span>`;

  tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3); tr.appendChild(td4);
  els.bucketRows.appendChild(tr);
}

function updateAll(){
  render();
}

/* =========================
   Event listeners
========================= */
els.league.addEventListener("change", populateTeams);
els.teamA.addEventListener("change", updateLabels);
els.teamB.addEventListener("change", updateLabels);

els.betType.addEventListener("change", ()=>{
  updateSideSelectors();
  updateAll();
});

[
  els.pregameSide, els.pregameLine, els.pregameOdds, els.pregameStake,
  els.liveSide, els.liveLine, els.liveOdds, els.liveStake, els.sliderMax
].forEach(el=>{
  el.addEventListener("input", ()=>{
    updateSideSelectors();
    syncSliderFromInputs();
    updateAll();
  });
});

els.stakeSlider.addEventListener("input", ()=>{
  els.liveStakeRead.textContent = `$${Number(els.stakeSlider.value).toFixed(0)}`;
  updateAll();
});

// navigation
els.to2a.addEventListener("click", ()=>{ setStepper(2); });
els.to3a.addEventListener("click", ()=>{ setStepper(3); });
els.to4a.addEventListener("click", ()=>{ setStepper(4); });

els.back1a.addEventListener("click", ()=>{ setStepper(1); });
els.back2a.addEventListener("click", ()=>{ setStepper(2); });
els.back3a.addEventListener("click", ()=>{ setStepper(3); });

els.reset.addEventListener("click", ()=>{
  resetDefaults();
  setStepper(1); });

// stepper click jump
[...els.stepper.querySelectorAll(".step")].forEach(s=>{
  s.addEventListener("click", ()=>{
    const n = Number(s.dataset.step);
    setStepper(n); });
});

/* =========================
   Init
========================= */
populateTeams();
resetDefaults();
setStepper(1);
</script>

  <div class="giftBottom">
    <img src="bottom%20photo.png" alt="Will’s Middling & Hedging Calculator - Bottom Banner" loading="lazy" decoding="async"/>
  </div>
</body>
</html>
