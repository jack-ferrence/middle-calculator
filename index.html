<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Will’s Middling Calculator</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#121a33;
      --card2:#0f1730;
      --text:#e9ecf5;
      --muted:#aeb6d4;
      --line:#23305c;
      --accent:#7aa2ff;
      --good:#28d17c;
      --bad:#ff5b6e;
      --warn:#ffcc66;
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 20% 10%, #18245a 0%, var(--bg) 55%) fixed;
      color:var(--text);
    }
    .wrap{
      max-width:1100px;
      margin:0 auto;
      padding:24px 16px 44px;
    }
    header{
      display:flex; align-items:flex-end; justify-content:space-between;
      gap:16px; margin-bottom:16px;
    }
    .title{
      display:flex; flex-direction:column; gap:6px;
    }
    h1{
      margin:0;
      font-size:22px;
      letter-spacing:.2px;
    }
    .subtitle{color:var(--muted); font-size:13px; line-height:1.35}
    .pill{
      padding:8px 10px;
      background: rgba(122,162,255,.12);
      border:1px solid rgba(122,162,255,.25);
      border-radius:999px;
      color:#dbe5ff;
      font-size:12px;
      white-space:nowrap;
    }

    .stepper{
      display:flex; gap:10px; align-items:center;
      margin:14px 0 18px;
      background: rgba(18,26,51,.7);
      border:1px solid rgba(35,48,92,.8);
      border-radius:999px;
      padding:10px 12px;
      box-shadow: var(--shadow);
      overflow:auto;
    }
    .step{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid transparent;
      color:var(--muted);
      min-width:max-content;
      user-select:none;
    }
    .step .num{
      width:22px; height:22px; border-radius:50%;
      display:grid; place-items:center;
      background: rgba(174,182,212,.12);
      border:1px solid rgba(174,182,212,.25);
      font-size:12px;
      color:var(--muted);
      flex:0 0 auto;
    }
    .step.active{
      color:var(--text);
      border-color: rgba(122,162,255,.45);
      background: rgba(122,162,255,.10);
    }
    .step.active .num{
      background: rgba(122,162,255,.20);
      border-color: rgba(122,162,255,.45);
      color:#dbe5ff;
    }
    .step.done{
      color:#dff7ea;
      border-color: rgba(40,209,124,.35);
      background: rgba(40,209,124,.10);
    }
    .step.done .num{
      background: rgba(40,209,124,.18);
      border-color: rgba(40,209,124,.35);
      color:#dff7ea;
    }

    .grid{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:14px;
    }
    @media (max-width: 900px){
      .grid{grid-template-columns:1fr}
    }

    .card{
      background: linear-gradient(180deg, rgba(18,26,51,.95) 0%, rgba(15,23,48,.92) 100%);
      border: 1px solid rgba(35,48,92,.85);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:16px;
    }
    .card h2{
      margin:0 0 12px;
      font-size:15px;
      letter-spacing:.2px;
      color:#eaf0ff;
    }
    .card p{margin:8px 0; color:var(--muted); font-size:13px; line-height:1.45}

    .panel{
      display:none;
      animation: fade .18s ease-out;
    }
    .panel.active{display:block}
    @keyframes fade{from{opacity:.6; transform: translateY(2px)}to{opacity:1; transform:none}}

    .form{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    .form.three{grid-template-columns: 1fr 1fr 1fr}
    .form.one{grid-template-columns: 1fr}
    @media (max-width: 700px){
      .form, .form.three{grid-template-columns:1fr}
    }

    label{
      display:block;
      font-size:12px;
      color:var(--muted);
      margin-bottom:6px;
    }
    input, select{
      width:100%;
      padding:10px 11px;
      border-radius:12px;
      border:1px solid rgba(35,48,92,.95);
      background: rgba(11,16,32,.65);
      color:var(--text);
      outline:none;
      font-size:14px;
    }
    input:focus, select:focus{border-color: rgba(122,162,255,.65)}
    .inline{
      display:flex; gap:10px; align-items:center;
    }
    .inline > *{flex:1}
    .help{
      font-size:12px;
      color:var(--muted);
      margin-top:6px;
    }

    .actions{
      display:flex;
      justify-content:space-between;
      gap:10px;
      margin-top:14px;
    }
    .btn{
      appearance:none;
      border:none;
      cursor:pointer;
      padding:10px 12px;
      border-radius:12px;
      font-weight:600;
      letter-spacing:.2px;
      font-size:13px;
    }
    .btn.primary{
      background: rgba(122,162,255,.95);
      color:#0b1020;
    }
    .btn.primary:active{transform: translateY(1px)}
    .btn.ghost{
      background: rgba(174,182,212,.10);
      border:1px solid rgba(174,182,212,.20);
      color: var(--text);
    }
    .btn.danger{
      background: rgba(255,91,110,.14);
      border:1px solid rgba(255,91,110,.35);
      color:#ffd8dd;
    }

    .rightStack{display:grid; gap:14px}
    .big{
      font-size:28px;
      margin:2px 0 4px;
      font-weight:800;
      letter-spacing:.2px;
    }
    .big.good{color: var(--good)}
    .big.bad{color: var(--bad)}
    .big.neutral{color:#eaf0ff}
    .smallRange{
      color:var(--muted);
      font-size:12px;
    }
    .kpiRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:10px;
    }
    .kpi{
      background: rgba(11,16,32,.55);
      border:1px solid rgba(35,48,92,.8);
      border-radius:16px;
      padding:12px;
    }
    .kpi .label{color:var(--muted); font-size:12px}
    .kpi .val{margin-top:6px; font-size:16px; font-weight:750}
    .kpi .val.good{color:var(--good)}
    .kpi .val.bad{color:var(--bad)}
    .kpi .val.warn{color:var(--warn)}

    .sliderWrap{
      background: rgba(11,16,32,.55);
      border:1px solid rgba(35,48,92,.8);
      border-radius:16px;
      padding:12px;
    }
    input[type="range"]{padding:0; height:34px}
    .sliderTop{
      display:flex; justify-content:space-between; align-items:baseline; gap:12px;
      margin-bottom:10px;
    }
    .sliderTop .val{
      font-size:18px; font-weight:800;
      color:#eaf0ff;
    }
    .table{
      width:100%;
      border-collapse: separate;
      border-spacing:0;
      overflow:hidden;
      border-radius:16px;
      border:1px solid rgba(35,48,92,.85);
      background: rgba(11,16,32,.55);
    }
    .table th, .table td{
      padding:10px 10px;
      font-size:12px;
      border-bottom:1px solid rgba(35,48,92,.65);
      vertical-align:top;
    }
    .table th{
      text-align:left;
      color: var(--muted);
      background: rgba(18,26,51,.35);
      font-weight:650;
    }
    .table tr:last-child td{border-bottom:none}
    .tag{
      display:inline-flex; align-items:center; gap:6px;
      padding:4px 8px; border-radius:999px;
      font-size:11px; font-weight:650;
      border:1px solid rgba(174,182,212,.22);
      background: rgba(174,182,212,.08);
      color:#eaf0ff;
      white-space:nowrap;
    }
    .tag.good{border-color: rgba(40,209,124,.35); background: rgba(40,209,124,.10); color:#dff7ea}
    .tag.bad{border-color: rgba(255,91,110,.35); background: rgba(255,91,110,.10); color:#ffd8dd}
    .tag.warn{border-color: rgba(255,204,102,.35); background: rgba(255,204,102,.10); color:#ffe8bb}

    .mutedLine{
      margin-top:10px;
      font-size:12px;
      color:var(--muted);
    }
    .divider{
      height:1px; background: rgba(35,48,92,.75);
      margin:14px 0;
    }
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Will’s Middling Calculator</h1>
        <div class="subtitle">Panel 1 → 2 → 3 → 4. Enter the pregame bet, enter the live hedge/middle, then use the slider to see outcome payouts instantly.</div>
      </div>
      <div class="pill">Neutral calculator · American odds · fast ranges (±15)</div>
    </header>

    <div class="stepper" id="stepper">
      <div class="step active" data-step="1"><div class="num">1</div><div>League & Teams</div></div>
      <div class="step" data-step="2"><div class="num">2</div><div>Pregame Bet</div></div>
      <div class="step" data-step="3"><div class="num">3</div><div>Live Middle Bet</div></div>
      <div class="step" data-step="4"><div class="num">4</div><div>Results</div></div>
    </div>

    <div class="grid">
      <div class="card">
        <!-- PANEL 1 -->
        <section class="panel active" id="panel1">
          <h2>Panel 1 — League & Teams</h2>
          <div class="form">
            <div>
              <label for="league">League</label>
              <select id="league">
                <option value="NFL">NFL</option>
                <option value="NBA">NBA</option>
              </select>
              <div class="help">Team dropdowns contain full league lists. Defaults are Team A / Team B, so picking teams is optional.</div>
            </div>
            <div></div>

            <div>
              <label for="teamA">Team A</label>
              <select id="teamA"></select>
            </div>
            <div>
              <label for="teamB">Team B</label>
              <select id="teamB"></select>
            </div>
          </div>

          <div class="actions">
            <button class="btn ghost" id="resetAll1">Reset</button>
            <button class="btn primary" id="to2">Next → Panel 2</button>
          </div>
        </section>

        <!-- PANEL 2 -->
        <section class="panel" id="panel2">
          <h2>Panel 2 — Pregame Bet (Original)</h2>
          <div class="form three">
            <div>
              <label for="market1">Market</label>
              <select id="market1">
                <option value="SPREAD">Spread</option>
                <option value="TOTAL">Total (Over/Under)</option>
                <option value="ML">Moneyline</option>
                <option value="CUSTOM_OU">Custom O/U Threshold</option>
              </select>
              <div class="help">Custom = any numeric threshold you’re tracking (same win/push rules as Over/Under).</div>
            </div>
            <div>
              <label for="side1">Side</label>
              <select id="side1"></select>
            </div>
            <div>
              <label for="stake1">Stake ($)</label>
              <input id="stake1" type="number" min="0" step="1" value="50" />
              <div class="help">Typical unit can be $20, but this stays fully flexible.</div>
            </div>

            <div id="line1Wrap">
              <label for="line1">Line</label>
              <input id="line1" type="number" step="0.5" value="-3.5" />
              <div class="help" id="line1Help">For spread: Team A margin + line > 0 wins. Push at 0.</div>
            </div>
            <div>
              <label for="odds1">American Odds</label>
              <input id="odds1" type="number" step="1" value="-110" />
              <div class="help">Examples: -110, +105, -125.</div>
            </div>
            <div>
              <label>Quick view</label>
              <div class="help mono" id="summary1">—</div>
            </div>
          </div>

          <div class="actions">
            <button class="btn ghost" id="backTo1">← Back</button>
            <button class="btn primary" id="to3">Next → Panel 3</button>
          </div>
        </section>

        <!-- PANEL 3 -->
        <section class="panel" id="panel3">
          <h2>Panel 3 — Live Middle Bet (Hedge)</h2>
          <div class="form three">
            <div>
              <label for="market2">Market</label>
              <select id="market2">
                <option value="SPREAD">Spread</option>
                <option value="TOTAL">Total (Over/Under)</option>
                <option value="ML">Moneyline</option>
                <option value="CUSTOM_OU">Custom O/U Threshold</option>
              </select>
              <div class="help">Keep this the same market as the pregame bet for true middles.</div>
            </div>
            <div>
              <label for="side2">Side (Live)</label>
              <select id="side2"></select>
            </div>
            <div>
              <label for="stake2Input">Live Stake ($)</label>
              <input id="stake2Input" type="number" min="0" step="1" value="0" />
              <div class="help">This is controlled by the slider below too.</div>
            </div>

            <div id="line2Wrap">
              <label for="line2">Live Line</label>
              <input id="line2" type="number" step="0.5" value="7.5" />
              <div class="help" id="line2Help">Example: Bears +7.5 on the other side creates a middle window.</div>
            </div>
            <div>
              <label for="odds2">Live American Odds</label>
              <input id="odds2" type="number" step="1" value="-110" />
              <div class="help">Range is auto-shown using ±15 (e.g., -110 → [-125, +?] when crossing 0 is handled).</div>
            </div>
            <div>
              <label>Quick view</label>
              <div class="help mono" id="summary2">—</div>
            </div>
          </div>

          <div class="divider"></div>

          <div class="sliderWrap">
            <div class="sliderTop">
              <div>
                <div class="help">Hedge stake slider (updates all payouts live)</div>
              </div>
              <div class="val">$<span id="stake2Val">0</span></div>
            </div>
            <input id="stake2" type="range" min="0" max="250" value="0" step="1" />
            <div class="help">Max auto-scales to 5× the pregame stake (adjust pregame stake to change range).</div>
          </div>

          <div class="actions">
            <button class="btn ghost" id="backTo2">← Back</button>
            <button class="btn primary" id="to4">Next → Panel 4</button>
          </div>
        </section>

        <!-- PANEL 4 -->
        <section class="panel" id="panel4">
          <h2>Panel 4 — Results (Payout Map)</h2>
          <p>Big number = expected net profit for the currently selected live stake. Small text = the payout range if live odds drift by ±15.</p>

          <div class="kpiRow">
            <div class="kpi">
              <div class="label">Best-case middle (both win)</div>
              <div class="val good" id="kpiMiddle">—</div>
              <div class="smallRange" id="kpiMiddleRange">—</div>
            </div>
            <div class="kpi">
              <div class="label">Worst-case (both lose)</div>
              <div class="val bad" id="kpiWorst">—</div>
              <div class="smallRange" id="kpiWorstRange">—</div>
            </div>
            <div class="kpi">
              <div class="label">If only pregame wins</div>
              <div class="val" id="kpiOnly1">—</div>
              <div class="smallRange" id="kpiOnly1Range">—</div>
            </div>
            <div class="kpi">
              <div class="label">If only live wins</div>
              <div class="val" id="kpiOnly2">—</div>
              <div class="smallRange" id="kpiOnly2Range">—</div>
            </div>
          </div>

          <div class="divider"></div>

          <table class="table" id="outcomeTable">
            <thead>
              <tr>
                <th style="width:20%">Outcome bucket</th>
                <th style="width:45%">What happened</th>
                <th style="width:35%">Net profit (with odds range)</th>
              </tr>
            </thead>
            <tbody id="outcomeBody"></tbody>
          </table>

          <div class="mutedLine" id="middleWindowLine">—</div>

          <div class="actions">
            <button class="btn ghost" id="backTo3">← Back</button>
            <button class="btn danger" id="resetAll4">Reset</button>
          </div>
        </section>
      </div>

      <div class="rightStack">
        <div class="card">
          <h2>Will’s Quick Read</h2>
          <div class="big neutral" id="bigNet">—</div>
          <div class="smallRange" id="bigRange">—</div>
          <div class="divider"></div>
          <div class="form one">
            <div>
              <label>At-a-glance</label>
              <div class="help" id="atAGlance">Enter bets in Panels 2–3. Slider updates everything.</div>
            </div>
          </div>
        </div>

        <div class="card">
          <h2>Math Notes (kept simple)</h2>
          <p><span class="tag">American odds</span> Profit for +X = stake×(X/100). Profit for -X = stake×(100/X).</p>
          <p><span class="tag warn">Push</span> returns stake (profit 0).</p>
          <p><span class="tag good">Middle</span> happens when both bets can win because the lines don’t overlap (spreads/totals/custom).</p>
          <p class="help mono" id="debugLine">—</p>
        </div>
      </div>
    </div>
  </div>

  <script>
    // -----------------------------
    // Data: NFL + NBA team lists
    // -----------------------------
    const TEAMS = {
      NFL: [
        "Arizona Cardinals","Atlanta Falcons","Baltimore Ravens","Buffalo Bills","Carolina Panthers","Chicago Bears",
        "Cincinnati Bengals","Cleveland Browns","Dallas Cowboys","Denver Broncos","Detroit Lions","Green Bay Packers",
        "Houston Texans","Indianapolis Colts","Jacksonville Jaguars","Kansas City Chiefs","Las Vegas Raiders","Los Angeles Chargers",
        "Los Angeles Rams","Miami Dolphins","Minnesota Vikings","New England Patriots","New Orleans Saints","New York Giants",
        "New York Jets","Philadelphia Eagles","Pittsburgh Steelers","San Francisco 49ers","Seattle Seahawks","Tampa Bay Buccaneers",
        "Tennessee Titans","Washington Commanders"
      ],
      NBA: [
        "Atlanta Hawks","Boston Celtics","Brooklyn Nets","Charlotte Hornets","Chicago Bulls","Cleveland Cavaliers","Dallas Mavericks",
        "Denver Nuggets","Detroit Pistons","Golden State Warriors","Houston Rockets","Indiana Pacers","LA Clippers","Los Angeles Lakers",
        "Memphis Grizzlies","Miami Heat","Milwaukee Bucks","Minnesota Timberwolves","New Orleans Pelicans","New York Knicks",
        "Oklahoma City Thunder","Orlando Magic","Philadelphia 76ers","Phoenix Suns","Portland Trail Blazers","Sacramento Kings",
        "San Antonio Spurs","Toronto Raptors","Utah Jazz","Washington Wizards"
      ]
    };

    // -----------------------------
    // Helpers: odds & bet grading
    // -----------------------------
    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function americanProfit(stake, americanOdds){
      const o = Number(americanOdds);
      const s = Number(stake);
      if (!isFinite(o) || !isFinite(s) || s < 0) return 0;
      if (o === 0) return 0;
      if (o > 0) return s * (o / 100);
      return s * (100 / Math.abs(o));
    }

    function gradeOU(resultValue, side, line){
      // resultValue compared to line
      // side: "OVER" or "UNDER"
      const r = Number(resultValue), L = Number(line);
      if (r === L) return "PUSH";
      if (side === "OVER") return (r > L) ? "WIN" : "LOSE";
      return (r < L) ? "WIN" : "LOSE";
    }

    function gradeSpread(teamAMargin, side, line){
      // teamAMargin = A - B
      // For a bet on Team A at line LA: win if teamAMargin + LA > 0
      // For a bet on Team B at line LB: equivalently win if -teamAMargin + LB > 0  (i.e., teamAMargin < LB)
      const m = Number(teamAMargin);
      const L = Number(line);
      if (side === "A"){
        const v = m + L;
        if (v === 0) return "PUSH";
        return v > 0 ? "WIN" : "LOSE";
      } else {
        const v = (-m) + L;
        if (v === 0) return "PUSH";
        return v > 0 ? "WIN" : "LOSE";
      }
    }

    function gradeML(winner, side){
      // winner: "A" or "B"
      return (winner === side) ? "WIN" : "LOSE";
    }

    function netForSingleBet(grade, stake, odds){
      const s = Number(stake);
      if (grade === "WIN") return americanProfit(s, odds);
      if (grade === "PUSH") return 0;
      return -s;
    }

    function formatMoney(n){
      const v = Number(n);
      const sign = v >= 0 ? "" : "-";
      const abs = Math.abs(v);
      return sign + "$" + abs.toFixed(2);
    }

    function oddsRange(o){
      // ±15 around american odds; keep sign continuity and avoid 0.
      const base = Number(o);
      if (!isFinite(base) || base === 0) return { low: base, high: base };
      let low = base - 15;
      let high = base + 15;

      // If crossing 0, skip 0 by snapping to +100/-100 convention.
      // Keep the endpoints away from 0 because american odds can't be 0.
      if (low < 0 && high > 0){
        // preserve direction: for display, set low negative, high positive,
        // but keep high at +100 minimum, low at -100 minimum.
        low = Math.min(low, -100);
        high = Math.max(high, +100);
      } else {
        // avoid -99..-1 and +1..+99 weirdness; snap to +/-100 if inside that band
        if (low > 0 && low < 100) low = 100;
        if (high > 0 && high < 100) high = 100;
        if (low < 0 && low > -100) low = -100;
        if (high < 0 && high > -100) high = -100;
      }
      // keep within a sane band
      low = clamp(low, -5000, 5000);
      high = clamp(high, -5000, 5000);
      if (low === 0) low = -100;
      if (high === 0) high = 100;
      return { low, high };
    }

    function outcomeTag(gr1, gr2){
      if (gr1 === "WIN" && gr2 === "WIN") return { text:"MIDDLE (both win)", cls:"good" };
      if (gr1 === "LOSE" && gr2 === "LOSE") return { text:"Both lose", cls:"bad" };
      if (gr1 === "PUSH" && gr2 === "PUSH") return { text:"Double push", cls:"warn" };
      if (gr1 === "PUSH" && gr2 === "WIN") return { text:"Push + Win", cls:"good" };
      if (gr1 === "WIN" && gr2 === "PUSH") return { text:"Win + Push", cls:"good" };
      if (gr1 === "PUSH" && gr2 === "LOSE") return { text:"Push + Lose", cls:"warn" };
      if (gr1 === "LOSE" && gr2 === "PUSH") return { text:"Lose + Push", cls:"warn" };
      if (gr1 === "WIN" && gr2 === "LOSE") return { text:"Only pregame wins", cls:"warn" };
      return { text:"Only live wins", cls:"warn" };
    }

    // -----------------------------
    // UI State
    // -----------------------------
    const els = {
      league: document.getElementById("league"),
      teamA: document.getElementById("teamA"),
      teamB: document.getElementById("teamB"),

      market1: document.getElementById("market1"),
      side1: document.getElementById("side1"),
      stake1: document.getElementById("stake1"),
      line1: document.getElementById("line1"),
      odds1: document.getElementById("odds1"),
      summary1: document.getElementById("summary1"),
      line1Wrap: document.getElementById("line1Wrap"),
      line1Help: document.getElementById("line1Help"),

      market2: document.getElementById("market2"),
      side2: document.getElementById("side2"),
      stake2: document.getElementById("stake2"),
      stake2Val: document.getElementById("stake2Val"),
      stake2Input: document.getElementById("stake2Input"),
      line2: document.getElementById("line2"),
      odds2: document.getElementById("odds2"),
      summary2: document.getElementById("summary2"),
      line2Wrap: document.getElementById("line2Wrap"),
      line2Help: document.getElementById("line2Help"),

      bigNet: document.getElementById("bigNet"),
      bigRange: document.getElementById("bigRange"),
      atAGlance: document.getElementById("atAGlance"),
      debugLine: document.getElementById("debugLine"),

      kpiMiddle: document.getElementById("kpiMiddle"),
      kpiMiddleRange: document.getElementById("kpiMiddleRange"),
      kpiWorst: document.getElementById("kpiWorst"),
      kpiWorstRange: document.getElementById("kpiWorstRange"),
      kpiOnly1: document.getElementById("kpiOnly1"),
      kpiOnly1Range: document.getElementById("kpiOnly1Range"),
      kpiOnly2: document.getElementById("kpiOnly2"),
      kpiOnly2Range: document.getElementById("kpiOnly2Range"),

      outcomeBody: document.getElementById("outcomeBody"),
      middleWindowLine: document.getElementById("middleWindowLine"),
      stepper: document.getElementById("stepper")
    };

    const panels = ["panel1","panel2","panel3","panel4"].map(id => document.getElementById(id));

    function setStep(n){
      panels.forEach((p,i)=> p.classList.toggle("active", i === (n-1)));
      const steps = els.stepper.querySelectorAll(".step");
      steps.forEach(s=>{
        const sn = Number(s.dataset.step);
        s.classList.toggle("active", sn === n);
        s.classList.toggle("done", sn < n);
      });
      recalcAll();
    }

    // -----------------------------
    // Populate teams + sides
    // -----------------------------
    function populateTeams(){
      const league = els.league.value;
      const list = TEAMS[league] || [];
      const mk = (sel) => {
        sel.innerHTML = "";
        const optA = document.createElement("option");
        optA.value = "__A__";
        optA.textContent = "Team A (default)";
        sel.appendChild(optA);

        const optB = document.createElement("option");
        optB.value = "__B__";
        optB.textContent = "Team B (default)";
        sel.appendChild(optB);

        const sep = document.createElement("option");
        sep.disabled = true;
        sep.textContent = "────────";
        sel.appendChild(sep);

        list.forEach(t=>{
          const o = document.createElement("option");
          o.value = t;
          o.textContent = t;
          sel.appendChild(o);
        });
      };
      mk(els.teamA);
      mk(els.teamB);
      els.teamA.value = "__A__";
      els.teamB.value = "__B__";
      populateSides();
    }

    function teamName(which){
      const v = which === "A" ? els.teamA.value : els.teamB.value;
      if (which === "A") return (v === "__A__" || v === "__B__") ? "Team A" : v;
      return (v === "__A__" || v === "__B__") ? "Team B" : v;
    }

    function populateSides(){
      const m1 = els.market1.value;
      const m2 = els.market2.value;

      els.side1.innerHTML = "";
      els.side2.innerHTML = "";

      const fill = (sel, market) => {
        if (market === "SPREAD"){
          sel.appendChild(new Option(`${teamName("A")} (Team A)`, "A"));
          sel.appendChild(new Option(`${teamName("B")} (Team B)`, "B"));
        } else if (market === "TOTAL" || market === "CUSTOM_OU"){
          sel.appendChild(new Option("Over", "OVER"));
          sel.appendChild(new Option("Under", "UNDER"));
        } else { // ML
          sel.appendChild(new Option(`${teamName("A")} (Team A)`, "A"));
          sel.appendChild(new Option(`${teamName("B")} (Team B)`, "B"));
        }
      };

      fill(els.side1, m1);
      fill(els.side2, m2);

      // default pairing for your example
      if (m1 === "SPREAD"){ els.side1.value = "A"; }
      if (m2 === "SPREAD"){ els.side2.value = "B"; }

      setLineHelp();
    }

    function setLineHelp(){
      const set = (market, helpEl) => {
        if (market === "SPREAD") helpEl.textContent = "Spread: Team A margin + line > 0 wins. Push at 0.";
        else if (market === "TOTAL") helpEl.textContent = "Total: Over wins if total > line. Under wins if total < line. Push at =.";
        else if (market === "CUSTOM_OU") helpEl.textContent = "Custom O/U: same rules as total; you interpret the number.";
        else helpEl.textContent = "Moneyline: wins if selected team wins. No middle window (just hedge).";
      };
      set(els.market1.value, els.line1Help);
      set(els.market2.value, els.line2Help);

      els.line1Wrap.style.display = (els.market1.value === "ML") ? "none" : "block";
      els.line2Wrap.style.display = (els.market2.value === "ML") ? "none" : "block";
    }

    // -----------------------------
    // Core calculation
    // -----------------------------
    function readBet(which){
      const is1 = which === 1;
      const market = is1 ? els.market1.value : els.market2.value;
      const side = is1 ? els.side1.value : els.side2.value;
      const stake = is1 ? Number(els.stake1.value) : Number(els.stake2.value);
      const odds = is1 ? Number(els.odds1.value) : Number(els.odds2.value);
      const line = (market === "ML") ? null : Number(is1 ? els.line1.value : els.line2.value);
      return { market, side, stake, odds, line };
    }

    function summarizeBet(b, label){
      if (b.market === "SPREAD"){
        const nm = (b.side === "A") ? teamName("A") : teamName("B");
        return `${label}: ${nm} ${b.line >= 0 ? "+" : ""}${b.line} @ ${fmtOdds(b.odds)} · $${b.stake}`;
      }
      if (b.market === "TOTAL"){
        return `${label}: ${b.side} ${b.line} @ ${fmtOdds(b.odds)} · $${b.stake}`;
      }
      if (b.market === "CUSTOM_OU"){
        return `${label}: ${b.side} ${b.line} @ ${fmtOdds(b.odds)} · $${b.stake}`;
      }
      const nm = (b.side === "A") ? teamName("A") : teamName("B");
      return `${label}: ${nm} ML @ ${fmtOdds(b.odds)} · $${b.stake}`;
    }

    function fmtOdds(o){
      const n = Number(o);
      if (!isFinite(n) || n === 0) return "—";
      return (n > 0 ? "+" : "") + Math.round(n);
    }

    function grade(b, scenario){
      // scenario depends on market:
      // SPREAD: scenario = { type:"SPREAD", marginA:number }
      // TOTAL/CUSTOM_OU: scenario = { type:"OU", total:number }
      // ML: scenario = { type:"ML", winner:"A"|"B" }
      if (b.market === "SPREAD") return gradeSpread(scenario.marginA, b.side, b.line);
      if (b.market === "TOTAL" || b.market === "CUSTOM_OU") return gradeOU(scenario.total, b.side, b.line);
      return gradeML(scenario.winner, b.side);
    }

    function netTwoBets(b1, b2, scenario, odds2Override=null){
      const g1 = grade(b1, scenario);
      const g2 = grade(b2, scenario);
      const n1 = netForSingleBet(g1, b1.stake, b1.odds);
      const n2 = netForSingleBet(g2, b2.stake, (odds2Override ?? b2.odds));
      return { net: n1 + n2, g1, g2 };
    }

    function computeBuckets(b1, b2){
      // Return descriptive buckets based on market.
      // For SPREAD & OU: produce intervals where grading changes (lines and implied boundaries).
      // For ML: produce two buckets (A wins, B wins).
      const sameMarket = b1.market === b2.market;

      if (!sameMarket){
        return [{ key:"mixed", desc:"Markets differ — treating as independent bets.", scenarios: [] }];
      }

      if (b1.market === "ML"){
        return [
          { key:"A", label:`${teamName("A")} wins`, scenario:{ type:"ML", winner:"A" } },
          { key:"B", label:`${teamName("B")} wins`, scenario:{ type:"ML", winner:"B" } }
        ];
      }

      if (b1.market === "SPREAD"){
        // boundaries for Team A margin where a bet flips:
        // For Team A side at line L: boundary at marginA = -L
        // For Team B side at line L: boundary at marginA = L
        function boundaryFor(b){
          return (b.side === "A") ? (-b.line) : (b.line);
        }
        const x1 = boundaryFor(b1);
        const x2 = boundaryFor(b2);
        const cuts = Array.from(new Set([x1, x2])).sort((a,b)=>a-b);

        // Buckets: (-inf, c1), (c1), (c1, c2), (c2), (c2, inf)
        const out = [];
        const mk = (from, to, label, repMargin) => out.push({ label, scenario:{ type:"SPREAD", marginA: repMargin }, from, to });

        const c1 = cuts[0];
        const c2 = cuts.length > 1 ? cuts[1] : cuts[0];

        mk(-Infinity, c1, `Team A margin < ${c1}`, c1 - 1);
        mk(c1, c1, `Team A margin = ${c1} (push point)`, c1);
        if (cuts.length > 1){
          mk(c1, c2, `Team A margin between ${c1} and ${c2}`, (c1 + c2)/2);
          mk(c2, c2, `Team A margin = ${c2} (push point)`, c2);
          mk(c2, Infinity, `Team A margin > ${c2}`, c2 + 1);
        } else {
          mk(c1, Infinity, `Team A margin > ${c1}`, c1 + 1);
        }
        return out;
      }

      // TOTAL / CUSTOM_OU
      const L1 = b1.line;
      const L2 = b2.line;
      const cuts = Array.from(new Set([L1, L2])).sort((a,b)=>a-b);
      const out = [];
      const mk = (from, to, label, repTotal) => out.push({ label, scenario:{ type:"OU", total: repTotal }, from, to });

      const c1 = cuts[0];
      const c2 = cuts.length > 1 ? cuts[1] : cuts[0];

      mk(-Infinity, c1, `Result < ${c1}`, c1 - 1);
      mk(c1, c1, `Result = ${c1} (push point)`, c1);
      if (cuts.length > 1){
        mk(c1, c2, `Result between ${c1} and ${c2}`, (c1 + c2)/2);
        mk(c2, c2, `Result = ${c2} (push point)`, c2);
        mk(c2, Infinity, `Result > ${c2}`, c2 + 1);
      } else {
        mk(c1, Infinity, `Result > ${c1}`, c1 + 1);
      }
      return out;
    }

    function middleWindowText(b1, b2){
      if (b1.market !== b2.market) return "Middle window: markets differ (no single window).";
      if (b1.market === "ML") return "Middle window: moneyline has no middle window (only hedge outcomes).";

      if (b1.market === "SPREAD"){
        // Determine if there exists a margin interval where both win.
        // Condition for b side A: marginA > -line
        // Condition for b side B: marginA < line
        const winInterval = (b) => {
          if (b.side === "A") return { lo: -b.line, hi: Infinity, openLo:true, openHi:true };
          return { lo: -Infinity, hi: b.line, openLo:true, openHi:true };
        };
        const a = winInterval(b1), b = winInterval(b2);
        const lo = Math.max(a.lo, b.lo);
        const hi = Math.min(a.hi, b.hi);
        if (lo < hi){
          return `Middle window (both win): Team A margin in (${fmtNum(lo)}, ${hi === Infinity ? "∞" : fmtNum(hi)})`;
        }
        return "Middle window (both win): none (lines overlap or same side).";
      }

      // OU
      // Over wins if result > line; Under wins if result < line
      const winIntervalOU = (b) => {
        if (b.side === "OVER") return { lo: b.line, hi: Infinity, openLo:true };
        return { lo: -Infinity, hi: b.line, openHi:true };
      };
      const a = winIntervalOU(b1), c = winIntervalOU(b2);
      const lo = Math.max(a.lo, c.lo);
      const hi = Math.min(a.hi ?? Infinity, c.hi ?? Infinity);
      if (lo < hi){
        return `Middle window (both win): result in (${fmtNum(lo)}, ${hi === Infinity ? "∞" : fmtNum(hi)})`;
      }
      return "Middle window (both win): none (lines overlap or same side).";
    }

    function fmtNum(x){
      if (x === Infinity) return "∞";
      if (x === -Infinity) return "-∞";
      const n = Number(x);
      if (!isFinite(n)) return "—";
      return (Math.round(n * 100) / 100).toString();
    }

    function render(){
      const b1 = readBet(1);
      const b2 = readBet(2);

      els.summary1.textContent = summarizeBet(b1, "Pregame");
      els.summary2.textContent = summarizeBet(b2, "Live");

      // odds range for live
      const r2 = oddsRange(b2.odds);

      // Choose a default "center" scenario for the big quick read:
      // Prefer the "middle" representative bucket if it exists; else use only1/only2/worst style.
      const buckets = computeBuckets(b1, b2);

      // Compute net for each bucket with base odds and with odds range
      const rows = [];
      let bestMiddle = null;
      let worst = null;
      let only1 = null;
      let only2 = null;

      function updBestWorst(netBase, netLow, netHigh, g1, g2){
        const tag = outcomeTag(g1, g2);

        if (g1 === "WIN" && g2 === "WIN"){
          if (!bestMiddle || netBase > bestMiddle.netBase){
            bestMiddle = { netBase, netLow, netHigh, tag };
          }
        }
        if (!worst || netBase < worst.netBase){
          worst = { netBase, netLow, netHigh, tag };
        }
        if ((g1 === "WIN" || g1 === "PUSH") && (g2 === "LOSE")){
          if (!only1 || netBase > only1.netBase){
            only1 = { netBase, netLow, netHigh, tag };
          }
        }
        if ((g2 === "WIN" || g2 === "PUSH") && (g1 === "LOSE")){
          if (!only2 || netBase > only2.netBase){
            only2 = { netBase, netLow, netHigh, tag };
          }
        }
      }

      // Render bucket table
      els.outcomeBody.innerHTML = "";
      buckets.forEach((bk) => {
        if (!bk.scenario){
          return;
        }
        const base = netTwoBets(b1, b2, bk.scenario, b2.odds);
        const low = netTwoBets(b1, b2, bk.scenario, r2.low);
        const high = netTwoBets(b1, b2, bk.scenario, r2.high);

        const tag = outcomeTag(base.g1, base.g2);
        updBestWorst(base.net, low.net, high.net, base.g1, base.g2);

        rows.push({ bk, base, low, high, tag });
      });

      // Fill table rows
      rows.forEach(r=>{
        const tr = document.createElement("tr");

        const td1 = document.createElement("td");
        const tag = document.createElement("span");
        tag.className = `tag ${r.tag.cls}`;
        tag.textContent = r.tag.text;
        td1.appendChild(tag);

        const td2 = document.createElement("td");
        let detail = "";
        if (b1.market === "SPREAD"){
          detail = `${r.bk.label}. Grading: Pregame=${r.base.g1}, Live=${r.base.g2}.`;
        } else if (b1.market === "TOTAL" || b1.market === "CUSTOM_OU"){
          detail = `${r.bk.label}. Grading: Pregame=${r.base.g1}, Live=${r.base.g2}.`;
        } else {
          detail = `${r.bk.label}. Grading: Pregame=${r.base.g1}, Live=${r.base.g2}.`;
        }
        td2.textContent = detail;

        const td3 = document.createElement("td");
        const baseTxt = formatMoney(r.base.net);
        const rangeTxt = `${formatMoney(Math.min(r.low.net, r.high.net))} to ${formatMoney(Math.max(r.low.net, r.high.net))}`;
        td3.innerHTML = `<div style="font-weight:800; font-size:13px; margin-bottom:2px;">${baseTxt}</div>
                         <div class="smallRange">(${rangeTxt} with live odds ±15)</div>`;

        tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);
        els.outcomeBody.appendChild(tr);
      });

      // KPI blocks
      function setKpi(elVal, elRange, obj, fallback, cls){
        if (!obj){
          elVal.textContent = fallback;
          elVal.className = "val " + (cls || "");
          elRange.textContent = "";
          return;
        }
        elVal.textContent = formatMoney(obj.netBase);
        elVal.className = "val " + (cls || obj.tag.cls);
        const lo = Math.min(obj.netLow, obj.netHigh);
        const hi = Math.max(obj.netLow, obj.netHigh);
        elRange.textContent = `(${formatMoney(lo)} to ${formatMoney(hi)} with live odds ±15)`;
      }

      setKpi(els.kpiMiddle, els.kpiMiddleRange, bestMiddle, "—", "good");
      setKpi(els.kpiWorst, els.kpiWorstRange, worst, "—", "bad");
      setKpi(els.kpiOnly1, els.kpiOnly1Range, only1, "—", "warn");
      setKpi(els.kpiOnly2, els.kpiOnly2Range, only2, "—", "warn");

      // Big quick read: use the "worst" vs "best middle" context + live stake selection
      // For a neutral quick read, show the midpoint bucket around relevant lines:
      let quickScenario = null;

      // Prefer: an actual middle bucket where both win (if any) to show upside
      const middleRow = rows.find(rr => rr.base.g1 === "WIN" && rr.base.g2 === "WIN");
      if (middleRow) quickScenario = middleRow;

      // Else use a representative bucket where only one side wins
      if (!quickScenario){
        const only1Row = rows.find(rr => rr.base.g1 === "WIN" && rr.base.g2 === "LOSE");
        const only2Row = rows.find(rr => rr.base.g1 === "LOSE" && rr.base.g2 === "WIN");
        quickScenario = only1Row || only2Row || rows[0] || null;
      }

      if (quickScenario){
        const net = quickScenario.base.net;
        const lo = Math.min(quickScenario.low.net, quickScenario.high.net);
        const hi = Math.max(quickScenario.low.net, quickScenario.high.net);
        els.bigNet.textContent = formatMoney(net);
        els.bigNet.className = "big " + (net >= 0 ? "good" : "bad");
        els.bigRange.textContent = `(${formatMoney(lo)} to ${formatMoney(hi)} with live odds ±15)`;
      } else {
        els.bigNet.textContent = "—";
        els.bigNet.className = "big neutral";
        els.bigRange.textContent = "—";
      }

      // Middle window line
      els.middleWindowLine.textContent = middleWindowText(b1, b2);

      // At-a-glance text
      const rTxt = `Live odds range: ${fmtOdds(r2.low)} to ${fmtOdds(r2.high)} (±15).`;
      els.atAGlance.textContent = `${summarizeBet(b1, "Pregame")} · ${summarizeBet(b2, "Live")} · ${rTxt}`;

      // Debug line
      els.debugLine.textContent = `League=${els.league.value} · Teams=${teamName("A")} vs ${teamName("B")} · Stake2 max=${els.stake2.max}`;
    }

    function recalcAll(){
      // Keep market2 aligned by default if user hasn’t changed it much; but do not force.
      setLineHelp();
      populateSides();
      syncSliderMax();
      syncStakeInputs();
      render();
    }

    function syncSliderMax(){
      const s1 = Number(els.stake1.value);
      const max = Math.max(100, Math.round((isFinite(s1) ? s1 : 50) * 5));
      els.stake2.max = String(max);
      // clamp current
      const cur = Number(els.stake2.value);
      if (cur > max) els.stake2.value = String(max);
    }

    function syncStakeInputs(){
      // slider -> input
      const v = Number(els.stake2.value);
      els.stake2Val.textContent = String(v);
      els.stake2Input.value = String(v);
    }

    // -----------------------------
    // Wiring: navigation
    // -----------------------------
    document.getElementById("to2").addEventListener("click", ()=>setStep(2));
    document.getElementById("to3").addEventListener("click", ()=>setStep(3));
    document.getElementById("to4").addEventListener("click", ()=>setStep(4));
    document.getElementById("backTo1").addEventListener("click", ()=>setStep(1));
    document.getElementById("backTo2").addEventListener("click", ()=>setStep(2));
    document.getElementById("backTo3").addEventListener("click", ()=>setStep(3));

    function resetAll(){
      els.league.value = "NFL";
      populateTeams();

      els.market1.value = "SPREAD";
      els.market2.value = "SPREAD";

      els.stake1.value = "50";
      els.odds1.value = "-110";
      els.line1.value = "-3.5";
      els.side1.value = "A";

      els.odds2.value = "-110";
      els.line2.value = "7.5";
      els.side2.value = "B";
      els.stake2.value = "0";
      syncSliderMax();
      syncStakeInputs();
      setStep(1);
    }

    document.getElementById("resetAll1").addEventListener("click", resetAll);
    document.getElementById("resetAll4").addEventListener("click", resetAll);

    // Stepper clicks
    els.stepper.querySelectorAll(".step").forEach(s=>{
      s.addEventListener("click", ()=>{
        const n = Number(s.dataset.step);
        setStep(n);
      });
    });

    // -----------------------------
    // Wiring: reactive updates
    // -----------------------------
    els.league.addEventListener("change", ()=>{ populateTeams(); recalcAll(); });
    els.teamA.addEventListener("change", ()=>{ populateSides(); recalcAll(); });
    els.teamB.addEventListener("change", ()=>{ populateSides(); recalcAll(); });

    [els.market1, els.market2].forEach(el=>{
      el.addEventListener("change", ()=>{
        setLineHelp();
        populateSides();
        recalcAll();
      });
    });

    [els.side1, els.side2, els.stake1, els.line1, els.odds1, els.line2, els.odds2].forEach(el=>{
      el.addEventListener("input", recalcAll);
      el.addEventListener("change", recalcAll);
    });

    els.stake2.addEventListener("input", ()=>{
      syncStakeInputs();
      render();
    });
    els.stake2Input.addEventListener("input", ()=>{
      const v = clamp(Number(els.stake2Input.value), 0, Number(els.stake2.max));
      els.stake2.value = String(isFinite(v) ? v : 0);
      syncStakeInputs();
      render();
    });

    // init
    populateTeams();
    resetAll();
    setStep(1);
  </script>
</body>
</html>
