<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Will’s Middling Calculator</title>
  <style>
    :root{
      --bg:#0b0f14; --card:#121826; --muted:#7d8aa5; --text:#e7edf7;
      --accent:#4da3ff; --good:#2ee59d; --bad:#ff5c7a; --warn:#ffd166;
      --border:rgba(231,237,247,.12);
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: radial-gradient(1200px 600px at 20% 0%, rgba(77,163,255,.15), transparent 60%),
                  radial-gradient(900px 500px at 90% 10%, rgba(46,229,157,.12), transparent 55%),
                  var(--bg);
      color:var(--text);
    }
    .wrap{max-width:1100px; margin:22px auto; padding:0 16px 40px;}
    header{
      display:flex; gap:14px; align-items:flex-end; justify-content:space-between; flex-wrap:wrap;
      padding:8px 0 18px; border-bottom:1px solid var(--border);
    }
    h1{margin:0; font-size:22px; letter-spacing:.2px;}
    .sub{margin:6px 0 0; color:var(--muted); font-size:13px; line-height:1.35}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      background: rgba(77,163,255,.12);
      border:1px solid rgba(77,163,255,.25);
      padding:6px 10px; border-radius:999px; font-size:12px; color:var(--text);
      user-select:none;
    }
    .grid{display:grid; grid-template-columns: 1fr 1fr; gap:14px; margin-top:16px;}
    @media (max-width: 980px){ .grid{grid-template-columns: 1fr;} }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border:1px solid var(--border);
      border-radius:16px;
      padding:14px;
      box-shadow: 0 8px 30px rgba(0,0,0,.22);
    }
    .card h2{margin:0 0 10px; font-size:15px;}
    .row{display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px;}
    .row3{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; margin-top:10px;}
    label{display:block; font-size:12px; color:var(--muted); margin-bottom:6px;}
    input, select{
      width:100%;
      background: rgba(255,255,255,.04);
      border:1px solid var(--border);
      color:var(--text);
      padding:10px 10px;
      border-radius:12px;
      outline:none;
      font-size:14px;
    }
    input:focus, select:focus{border-color: rgba(77,163,255,.55); box-shadow: 0 0 0 3px rgba(77,163,255,.14);}
    .mono{font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    .help{color:var(--muted); font-size:12px; margin-top:8px; line-height:1.35}
    .big{
      display:flex; gap:12px; flex-wrap:wrap; align-items:stretch; margin-top:14px;
    }
    .metric{
      flex:1 1 260px;
      background: rgba(0,0,0,.22);
      border:1px solid var(--border);
      border-radius:16px;
      padding:12px;
    }
    .metric .k{color:var(--muted); font-size:12px; margin-bottom:6px;}
    .metric .v{font-size:22px; font-weight:700;}
    .metric .s{color:var(--muted); font-size:12px; margin-top:6px;}
    .good{color:var(--good)} .bad{color:var(--bad)} .warn{color:var(--warn)}
    .sliderWrap{
      margin-top:10px;
      padding:12px;
      border-radius:16px;
      border:1px dashed rgba(231,237,247,.20);
      background: rgba(0,0,0,.14);
    }
    input[type="range"]{padding:0; background: transparent; border:none;}
    .sliderTop{
      display:flex; align-items:baseline; justify-content:space-between; gap:12px; flex-wrap:wrap;
      margin-bottom:8px;
    }
    .sliderTop .amt{font-size:18px; font-weight:700;}
    .btnRow{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;}
    button{
      appearance:none; border:1px solid var(--border);
      background: rgba(255,255,255,.05);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-size:13px;
      cursor:pointer;
    }
    button:hover{border-color: rgba(77,163,255,.45);}
    table{
      width:100%;
      border-collapse:collapse;
      margin-top:12px;
      overflow:hidden;
      border-radius:16px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.18);
    }
    th, td{
      padding:10px 10px;
      border-bottom:1px solid rgba(231,237,247,.08);
      font-size:13px;
      vertical-align:top;
    }
    th{color:var(--muted); font-weight:600; text-align:left;}
    tr:last-child td{border-bottom:none;}
    .noteSmall{color:var(--muted); font-size:12px;}
    .tag{
      display:inline-block; padding:3px 8px; border-radius:999px; font-size:11px;
      border:1px solid rgba(231,237,247,.14); color:var(--text); background: rgba(255,255,255,.03);
    }
    .okLine{color:var(--good); font-weight:700;}
    .badLine{color:var(--bad); font-weight:700;}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Will’s Middling Calculator</h1>
        <div class="sub">Enter your pre-game bet and the live bet you’re considering. Use the slider to size the live bet and see the full payout layout instantly (with a ±15 odds drift range).</div>
      </div>
      <div class="pill mono">Unit ≈ $20 • Neutral calculator • American odds</div>
    </header>

    <div class="grid">
      <div class="card">
        <h2>1) League & Teams</h2>
        <div class="row">
          <div>
            <label for="league">League</label>
            <select id="league">
              <option value="NFL" selected>NFL</option>
              <option value="NBA">NBA</option>
            </select>
          </div>
          <div>
            <label for="unitsize">Unit size (optional)</label>
            <input id="unitsize" type="number" min="1" step="1" value="20" class="mono" />
          </div>
        </div>
        <div class="row">
          <div>
            <label for="teamA">Team A</label>
            <select id="teamA"></select>
          </div>
          <div>
            <label for="teamB">Team B</label>
            <select id="teamB"></select>
          </div>
        </div>
        <div class="help">Defaults are “Team A / Team B” so you can skip team selection. Teams only label outcomes.</div>
      </div>

      <div class="card">
        <h2>2) Pre-game Bet (Already Placed)</h2>
        <div class="row3">
          <div>
            <label for="preType">Bet type</label>
            <select id="preType">
              <option value="SPREAD" selected>Spread</option>
              <option value="TOTAL">Total (O/U)</option>
              <option value="ML">Moneyline</option>
            </select>
          </div>
          <div>
            <label for="preTeam">Side / Team</label>
            <select id="preTeam">
              <option value="A" selected>Team A</option>
              <option value="B">Team B</option>
              <option value="OVER">Over</option>
              <option value="UNDER">Under</option>
            </select>
          </div>
          <div>
            <label for="preOdds">Odds (American)</label>
            <input id="preOdds" type="number" step="1" value="-110" class="mono" />
          </div>
        </div>
        <div class="row">
          <div>
            <label for="preLine">Line (spread/total). For ML leave blank.</label>
            <input id="preLine" type="number" step="0.5" value="-3.5" class="mono" />
          </div>
          <div>
            <label for="preStake">Stake ($)</label>
            <input id="preStake" type="number" step="1" value="50" class="mono" />
          </div>
        </div>
        <div class="help">Example: Packers -3.5 for $50 at -110.</div>
      </div>

      <div class="card">
        <h2>3) Live Bet (Middle Attempt)</h2>
        <div class="row3">
          <div>
            <label for="liveType">Bet type</label>
            <select id="liveType">
              <option value="SPREAD" selected>Spread</option>
              <option value="TOTAL">Total (O/U)</option>
              <option value="ML">Moneyline</option>
            </select>
          </div>
          <div>
            <label for="liveTeam">Side / Team</label>
            <select id="liveTeam">
              <option value="B" selected>Team B</option>
              <option value="A">Team A</option>
              <option value="OVER">Over</option>
              <option value="UNDER">Under</option>
            </select>
          </div>
          <div>
            <label for="liveOdds">Odds now (American)</label>
            <input id="liveOdds" type="number" step="1" value="-110" class="mono" />
          </div>
        </div>
        <div class="row">
          <div>
            <label for="liveLine">Line now (spread/total). For ML leave blank.</label>
            <input id="liveLine" type="number" step="0.5" value="+7.5" class="mono" />
          </div>
          <div>
            <label for="drift">Assumed odds drift (±)</label>
            <input id="drift" type="number" step="1" value="15" class="mono" />
          </div>
        </div>

        <div class="sliderWrap">
          <div class="sliderTop">
            <div>
              <div class="noteSmall">Live stake slider</div>
              <div class="amt mono" id="liveStakeLabel">$50</div>
            </div>
            <div class="noteSmall mono" id="unitsHint">~2.5 units @ $20</div>
          </div>
          <input id="liveStake" type="range" min="0" max="400" step="1" value="50" />
          <div class="row">
            <div>
              <label for="liveStakeMax">Slider max ($)</label>
              <input id="liveStakeMax" type="number" step="10" value="400" class="mono" />
            </div>
            <div>
              <label for="liveStakeStep">Slider step ($)</label>
              <input id="liveStakeStep" type="number" step="1" value="1" class="mono" />
            </div>
          </div>
          <div class="btnRow">
            <button id="setToUnits1">Set live stake = 1 unit</button>
            <button id="setToUnits2">Set live stake = 2 units</button>
            <button id="setToUnits5">Set live stake = 5 units</button>
            <button id="reset">Reset example</button>
          </div>
          <div class="help">Slider drives the live bet size only. Odds drift range applies to the live bet only.</div>
        </div>
      </div>

      <div class="card">
        <h2>4) Outputs</h2>
        <div class="big">
          <div class="metric">
            <div class="k">Do nothing: worst-case net</div>
            <div class="v mono" id="dnWorst">$0</div>
            <div class="s mono" id="dnWorstDetail"></div>
          </div>
          <div class="metric">
            <div class="k">With live bet: worst-case net</div>
            <div class="v mono" id="wbWorst">$0</div>
            <div class="s mono" id="wbWorstDetail"></div>
          </div>
          <div class="metric">
            <div class="k">Middle window (if applicable)</div>
            <div class="v mono" id="middleWindow">—</div>
            <div class="s" id="middleNote"></div>
          </div>
        </div>

        <table>
          <thead>
            <tr>
              <th>Game outcome bucket</th>
              <th>Pre-game bet result</th>
              <th>Live bet result</th>
              <th>Net profit now</th>
              <th class="noteSmall">Net profit with odds drift</th>
            </tr>
          </thead>
          <tbody id="outcomesBody"></tbody>
        </table>

        <div class="help">
          “Net profit” = total profits from winning bets − stakes lost on losing bets. Push = $0 on that bet.
          The drift range uses live odds ± drift (clamped away from 0).
        </div>
      </div>
    </div>
  </div>

<script>
/* ------------------ Team Lists ------------------ */
const TEAMS = {
  NFL: [
    "Team A","Team B",
    "Arizona Cardinals","Atlanta Falcons","Baltimore Ravens","Buffalo Bills","Carolina Panthers",
    "Chicago Bears","Cincinnati Bengals","Cleveland Browns","Dallas Cowboys","Denver Broncos",
    "Detroit Lions","Green Bay Packers","Houston Texans","Indianapolis Colts","Jacksonville Jaguars",
    "Kansas City Chiefs","Las Vegas Raiders","Los Angeles Chargers","Los Angeles Rams","Miami Dolphins",
    "Minnesota Vikings","New England Patriots","New Orleans Saints","New York Giants","New York Jets",
    "Philadelphia Eagles","Pittsburgh Steelers","San Francisco 49ers","Seattle Seahawks","Tampa Bay Buccaneers",
    "Tennessee Titans","Washington Commanders"
  ],
  NBA: [
    "Team A","Team B",
    "Atlanta Hawks","Boston Celtics","Brooklyn Nets","Charlotte Hornets","Chicago Bulls","Cleveland Cavaliers",
    "Dallas Mavericks","Denver Nuggets","Detroit Pistons","Golden State Warriors","Houston Rockets","Indiana Pacers",
    "Los Angeles Clippers","Los Angeles Lakers","Memphis Grizzlies","Miami Heat","Milwaukee Bucks","Minnesota Timberwolves",
    "New Orleans Pelicans","New York Knicks","Oklahoma City Thunder","Orlando Magic","Philadelphia 76ers","Phoenix Suns",
    "Portland Trail Blazers","Sacramento Kings","San Antonio Spurs","Toronto Raptors","Utah Jazz","Washington Wizards"
  ]
};

/* ------------------ Odds Math ------------------ */
function clampAmericanOdds(x){
  // avoid 0 and tiny absolute values that break formulas
  if (!Number.isFinite(x)) return -110;
  if (x === 0) return -110;
  if (x > -1 && x < 1) return x < 0 ? -1 : 1;
  return x;
}

function profitFromAmericanOdds(stake, odds){
  odds = clampAmericanOdds(odds);
  if (stake <= 0) return 0;
  if (odds > 0) return stake * (odds / 100);
  return stake * (100 / Math.abs(odds));
}

function formatMoney(x){
  const s = (Math.round(x * 100) / 100).toFixed(2);
  return (x < 0 ? "-$" + Math.abs(s) : "$" + s);
}

function netForBetResult(stake, odds, result){
  // result: "WIN" | "LOSE" | "PUSH"
  if (stake <= 0) return 0;
  if (result === "PUSH") return 0;
  if (result === "LOSE") return -stake;
  return profitFromAmericanOdds(stake, odds);
}

function driftOddsRange(odds, drift){
  odds = clampAmericanOdds(odds);
  drift = Math.max(0, Math.floor(Number(drift) || 0));
  const lo = clampAmericanOdds(odds - drift);
  const hi = clampAmericanOdds(odds + drift);
  // For readability, ensure lo <= hi numerically, but with american odds signs it’s fine to just return both
  return { lo, hi };
}

/* ------------------ Outcome Logic ------------------ */
function isSpreadOrTotal(type){ return type === "SPREAD" || type === "TOTAL"; }

function computeWindow(preType, preSide, preLine, liveType, liveSide, liveLine){
  // Returns { applies: boolean, text: string, note: string, buckets: [...] }
  // buckets: list of { label, conditionText, preResult, liveResult }
  // We'll model three buckets where applicable:
  // Spread: if pre is A -x and live is B +y -> middle is margin in [x+1 .. y] for integer scoring, but we keep it as line window (x, y)
  // Totals: if pre Over a and live Under b (a < b) => middle when total in (a, b)
  // Moneyline: no middle window in the classic sense (hedge only): two buckets (A wins/B wins)

  const buckets = [];

  // Handle mismatch types: still compute hedge buckets based on independent settlement; "window" not meaningful
  const sameType = (preType === liveType);

  if (preType === "ML" || liveType === "ML"){
    // Moneyline hedge: buckets by winner
    buckets.push({
      label: "Team A wins",
      conditionText: "Team A wins the game",
      preResult: (preSide === "A") ? "WIN" : (preSide === "B" ? "LOSE" : "PUSH"),
      liveResult: (liveSide === "A") ? "WIN" : (liveSide === "B" ? "LOSE" : "PUSH")
    });
    buckets.push({
      label: "Team B wins",
      conditionText: "Team B wins the game",
      preResult: (preSide === "B") ? "WIN" : (preSide === "A" ? "LOSE" : "PUSH"),
      liveResult: (liveSide === "B") ? "WIN" : (liveSide === "A" ? "LOSE" : "PUSH")
    });
    return { applies:false, text:"—", note:"Moneyline hedging: no middle window, just winner-based outcomes.", buckets };
  }

  if (!sameType){
    // Different markets: show generic buckets without "middle"
    buckets.push({ label:"Pre wins / Live loses", conditionText:"Pre bet wins; live bet loses", preResult:"WIN", liveResult:"LOSE" });
    buckets.push({ label:"Pre loses / Live wins", conditionText:"Pre bet loses; live bet wins", preResult:"LOSE", liveResult:"WIN" });
    buckets.push({ label:"Both push/other", conditionText:"Push scenarios depend on exact lines", preResult:"PUSH", liveResult:"PUSH" });
    return { applies:false, text:"—", note:"Different bet types: calculator will still do payout math per bucket labels.", buckets };
  }

  if (preType === "TOTAL"){
    // Need Over then Under for a middle window (or Under then Over)
    const preIsOver = (preSide === "OVER");
    const preIsUnder = (preSide === "UNDER");
    const liveIsOver = (liveSide === "OVER");
    const liveIsUnder = (liveSide === "UNDER");

    const a = Number(preLine);
    const b = Number(liveLine);
    if (!Number.isFinite(a) || !Number.isFinite(b)){
      buckets.push({ label:"Over hits", conditionText:"Total goes high enough for Over", preResult: preIsOver?"WIN":"LOSE", liveResult: liveIsOver?"WIN":"LOSE" });
      buckets.push({ label:"Under hits", conditionText:"Total stays low enough for Under", preResult: preIsUnder?"WIN":"LOSE", liveResult: liveIsUnder?"WIN":"LOSE" });
      return { applies:false, text:"—", note:"Enter total lines to show a middle window.", buckets };
    }

    // Case: pre Over a, live Under b with a < b => middle window (a, b)
    if (preIsOver && liveIsUnder && a < b){
      buckets.push({ label:"Under a", conditionText:`Final total < ${a}`, preResult:"LOSE", liveResult:"WIN" });
      buckets.push({ label:"Middle", conditionText:`Final total between ${a} and ${b}`, preResult:"WIN", liveResult:"WIN" });
      buckets.push({ label:"Over b", conditionText:`Final total > ${b}`, preResult:"WIN", liveResult:"LOSE" });
      return { applies:true, text:`(${a}, ${b})`, note:"Totals middle: both bets can win if the final total lands between the two numbers.", buckets };
    }

    // Case: pre Under a, live Over b with b < a => middle window (b, a)
    if (preIsUnder && liveIsOver && b < a){
      buckets.push({ label:"Under b", conditionText:`Final total < ${b}`, preResult:"WIN", liveResult:"LOSE" });
      buckets.push({ label:"Middle", conditionText:`Final total between ${b} and ${a}`, preResult:"WIN", liveResult:"WIN" });
      buckets.push({ label:"Over a", conditionText:`Final total > ${a}`, preResult:"LOSE", liveResult:"WIN" });
      return { applies:true, text:`(${b}, ${a})`, note:"Totals middle: both bets can win if the final total lands between the two numbers.", buckets };
    }

    // Otherwise it’s a hedge but not a true middle
    buckets.push({ label:"Low total", conditionText:"Lower total outcome", preResult: preIsUnder?"WIN":"LOSE", liveResult: liveIsUnder?"WIN":"LOSE" });
    buckets.push({ label:"High total", conditionText:"Higher total outcome", preResult: preIsOver?"WIN":"LOSE", liveResult: liveIsOver?"WIN":"LOSE" });
    return { applies:false, text:"—", note:"No middle window (lines don’t create Over/Under overlap). Still a hedge calculator.", buckets };
  }

  if (preType === "SPREAD"){
    // Spread sides are A or B; lines are numeric attached to that team.
    const preIsA = (preSide === "A");
    const preIsB = (preSide === "B");
    const liveIsA = (liveSide === "A");
    const liveIsB = (liveSide === "B");

    const p = Number(preLine);
    const l = Number(liveLine);
    if (!Number.isFinite(p) || !Number.isFinite(l)){
      buckets.push({ label:"Team A covers", conditionText:"Team A covers its spread", preResult: preIsA?"WIN":"LOSE", liveResult: liveIsA?"WIN":"LOSE" });
      buckets.push({ label:"Team B covers", conditionText:"Team B covers its spread", preResult: preIsB?"WIN":"LOSE", liveResult: liveIsB?"WIN":"LOSE" });
      return { applies:false, text:"—", note:"Enter spread lines to show a middle window.", buckets };
    }

    // Typical middle: pre A -3.5, live B +7.5
    // Middle window exists when pre and live are opposite teams and there is a gap.
    if (preIsA && liveIsB && (Math.abs(p) > 0 || Math.abs(l) > 0)){
      // For A line p (likely negative) and B line l (likely positive). Middle exists if (-p) < l when p negative.
      // Normalize to "A needs to win by > abs(p)" and "A can win by < l" for B +l.
      // We'll describe window in terms of Team A winning margin.
      const aNeed = -p;      // if p=-3.5 => 3.5
      const aMax = l;        // if l=+7.5 => 7.5
      if (Number.isFinite(aNeed) && Number.isFinite(aMax) && aNeed < aMax){
        buckets.push({ label:"Team A wins small / loses", conditionText:`Team A margin < ${aNeed} (or Team B wins)`, preResult:"LOSE", liveResult:"WIN" });
        buckets.push({ label:"Middle", conditionText:`Team A margin between ${aNeed} and ${aMax}`, preResult:"WIN", liveResult:"WIN" });
        buckets.push({ label:"Team A wins big", conditionText:`Team A margin > ${aMax}`, preResult:"WIN", liveResult:"LOSE" });
        return { applies:true, text:`Team A margin in (${aNeed}, ${aMax})`, note:"Spread middle: both bets can win when the final margin lands between the two spread numbers.", buckets };
      }
    }

    if (preIsB && liveIsA){
      const bNeed = -p; // if pre is B with p=+7.5 then -p = -7.5 (not useful)
      // Build similarly but from Team B perspective; easiest: swap labels by mirroring A/B.
      // Convert to "Team B margin" window
      const bMin = -l;   // if live is A -3.5 => -(-3.5)=3.5
      const bMax = p;    // if pre is B +7.5 => 7.5
      if (Number.isFinite(bMin) && Number.isFinite(bMax) && bMin < bMax){
        buckets.push({ label:"Team B wins small / loses", conditionText:`Team B margin < ${bMin} (or Team A wins)`, preResult:"LOSE", liveResult:"WIN" });
        buckets.push({ label:"Middle", conditionText:`Team B margin between ${bMin} and ${bMax}`, preResult:"WIN", liveResult:"WIN" });
        buckets.push({ label:"Team B wins big", conditionText:`Team B margin > ${bMax}`, preResult:"WIN", liveResult:"LOSE" });
        return { applies:true, text:`Team B margin in (${bMin}, ${bMax})`, note:"Spread middle: both bets can win when the final margin lands between the two spread numbers.", buckets };
      }
    }

    // Otherwise hedge only
    buckets.push({ label:"Pre side covers", conditionText:"Pre side covers", preResult:"WIN", liveResult:"LOSE" });
    buckets.push({ label:"Live side covers", conditionText:"Live side covers", preResult:"LOSE", liveResult:"WIN" });
    return { applies:false, text:"—", note:"No middle window (lines don’t create a gap). Still a hedge calculator.", buckets };
  }

  return { applies:false, text:"—", note:"—", buckets:[{label:"—",conditionText:"—",preResult:"PUSH",liveResult:"PUSH"}] };
}

/* ------------------ UI Wiring ------------------ */
const el = (id)=>document.getElementById(id);

function fillTeams(){
  const league = el("league").value;
  const list = TEAMS[league] || ["Team A","Team B"];
  const a = el("teamA");
  const b = el("teamB");

  a.innerHTML = "";
  b.innerHTML = "";
  for (const t of list){
    const o1 = document.createElement("option");
    o1.value = t; o1.textContent = t;
    a.appendChild(o1);

    const o2 = document.createElement("option");
    o2.value = t; o2.textContent = t;
    b.appendChild(o2);
  }
  a.value = "Team A";
  b.value = "Team B";
}

function sideLabel(side, teamA, teamB){
  if (side === "A") return teamA;
  if (side === "B") return teamB;
  if (side === "OVER") return "Over";
  if (side === "UNDER") return "Under";
  return side;
}

function setSliderConfig(){
  const max = Math.max(0, Number(el("liveStakeMax").value) || 0);
  const step = Math.max(1, Number(el("liveStakeStep").value) || 1);
  const s = el("liveStake");
  s.max = String(max);
  s.step = String(step);
  if (Number(s.value) > max) s.value = String(max);
}

function updateUnitsHint(){
  const unit = Math.max(1, Number(el("unitsize").value) || 20);
  const stake = Number(el("liveStake").value) || 0;
  el("unitsHint").textContent = `~${(stake/unit).toFixed(2)} units @ $${unit}`;
}

function update(){
  const teamA = el("teamA").value || "Team A";
  const teamB = el("teamB").value || "Team B";

  const preType = el("preType").value;
  const preSide = el("preTeam").value;
  const preOdds = clampAmericanOdds(Number(el("preOdds").value));
  const preLineRaw = el("preLine").value.trim();
  const preLine = preLineRaw === "" ? NaN : Number(preLineRaw);
  const preStake = Math.max(0, Number(el("preStake").value) || 0);

  const liveType = el("liveType").value;
  const liveSide = el("liveTeam").value;
  const liveOddsNow = clampAmericanOdds(Number(el("liveOdds").value));
  const liveLineRaw = el("liveLine").value.trim();
  const liveLine = liveLineRaw === "" ? NaN : Number(liveLineRaw);
  const liveStake = Math.max(0, Number(el("liveStake").value) || 0);
  const drift = Math.max(0, Math.floor(Number(el("drift").value) || 0));

  el("liveStakeLabel").textContent = `$${liveStake.toFixed(0)}`;
  updateUnitsHint();

  const {lo: liveOddsLo, hi: liveOddsHi} = driftOddsRange(liveOddsNow, drift);

  // Window & buckets
  const window = computeWindow(preType, preSide, preLine, liveType, liveSide, liveLine);
  el("middleWindow").textContent = window.applies ? window.text : "—";
  el("middleNote").textContent = window.note || "—";

  // Do-nothing worst case: evaluate only pre bet against two buckets (win/lose/push)
  // We'll compute based on buckets we have; if buckets include WIN/LOSE/PUSH, derive min net.
  let dnMin = Infinity, dnMinText = "";
  for (const b of window.buckets){
    const netPre = netForBetResult(preStake, preOdds, b.preResult);
    if (netPre < dnMin){
      dnMin = netPre;
      dnMinText = `${b.label}: ${b.preResult}`;
    }
  }
  if (!Number.isFinite(dnMin)) dnMin = 0;

  // With bet worst case (now odds)
  let wbMinNow = Infinity, wbMinNowText = "";
  // With drift: compute min over buckets AND over drift endpoints for live odds
  let wbMinDrift = Infinity, wbMinDriftText = "";

  const body = el("outcomesBody");
  body.innerHTML = "";

  for (const b of window.buckets){
    const netPre = netForBetResult(preStake, preOdds, b.preResult);
    const netLiveNow = netForBetResult(liveStake, liveOddsNow, b.liveResult);
    const netNow = netPre + netLiveNow;

    const netLiveLo = netForBetResult(liveStake, liveOddsLo, b.liveResult);
    const netLiveHi = netForBetResult(liveStake, liveOddsHi, b.liveResult);
    const netRangeMin = Math.min(netPre + netLiveLo, netPre + netLiveHi);
    const netRangeMax = Math.max(netPre + netLiveLo, netPre + netLiveHi);

    if (netNow < wbMinNow){
      wbMinNow = netNow;
      wbMinNowText = `${b.label}: pre ${b.preResult}, live ${b.liveResult}`;
    }
    if (netRangeMin < wbMinDrift){
      wbMinDrift = netRangeMin;
      wbMinDriftText = `${b.label}: min drift case`;
    }

    const tr = document.createElement("tr");

    const c1 = document.createElement("td");
    c1.innerHTML = `<div class="tag">${b.label}</div><div class="noteSmall" style="margin-top:6px">${b.conditionText}</div>`;

    const c2 = document.createElement("td");
    c2.innerHTML = `<span class="mono">${sideLabel(preSide, teamA, teamB)}</span><div class="${b.preResult==='WIN'?'okLine':(b.preResult==='LOSE'?'badLine':'')}">${b.preResult}</div>`;

    const c3 = document.createElement("td");
    c3.innerHTML = `<span class="mono">${sideLabel(liveSide, teamA, teamB)}</span><div class="${b.liveResult==='WIN'?'okLine':(b.liveResult==='LOSE'?'badLine':'')}">${b.liveResult}</div>`;

    const c4 = document.createElement("td");
    const cls = netNow >= 0 ? "good" : "bad";
    c4.innerHTML = `<div class="mono ${cls}" style="font-weight:700">${formatMoney(netNow)}</div>`;

    const c5 = document.createElement("td");
    c5.innerHTML = `<div class="mono noteSmall">${formatMoney(netRangeMin)} to ${formatMoney(netRangeMax)}</div>`;

    tr.appendChild(c1); tr.appendChild(c2); tr.appendChild(c3); tr.appendChild(c4); tr.appendChild(c5);
    body.appendChild(tr);
  }

  // Render big metrics
  const dnCls = dnMin >= 0 ? "good" : "bad";
  el("dnWorst").className = `v mono ${dnCls}`;
  el("dnWorst").textContent = formatMoney(dnMin);
  el("dnWorstDetail").textContent = dnMinText ? `Worst bucket: ${dnMinText}` : "";

  const wbCls = wbMinNow >= 0 ? "good" : "bad";
  el("wbWorst").className = `v mono ${wbCls}`;
  el("wbWorst").textContent = formatMoney(wbMinNow);
  el("wbWorstDetail").textContent =
    `Worst bucket now: ${wbMinNowText || "—"} (drift min: ${formatMoney(wbMinDrift)})`;

}

/* ------------------ Event Hooks ------------------ */
function hook(){
  const ids = [
    "league","unitsize","teamA","teamB",
    "preType","preTeam","preOdds","preLine","preStake",
    "liveType","liveTeam","liveOdds","liveLine","drift",
    "liveStake","liveStakeMax","liveStakeStep"
  ];
  for (const id of ids){
    el(id).addEventListener("input", ()=>{
      if (id === "league") fillTeams();
      if (id === "liveStakeMax" || id === "liveStakeStep") setSliderConfig();
      update();
    });
  }

  el("setToUnits1").addEventListener("click", ()=>{
    const unit = Math.max(1, Number(el("unitsize").value) || 20);
    el("liveStake").value = String(Math.round(unit));
    update();
  });
  el("setToUnits2").addEventListener("click", ()=>{
    const unit = Math.max(1, Number(el("unitsize").value) || 20);
    el("liveStake").value = String(Math.round(unit*2));
    update();
  });
  el("setToUnits5").addEventListener("click", ()=>{
    const unit = Math.max(1, Number(el("unitsize").value) || 20);
    el("liveStake").value = String(Math.round(unit*5));
    update();
  });

  el("reset").addEventListener("click", ()=>{
    el("league").value = "NFL";
    fillTeams();
    el("unitsize").value = 20;

    el("preType").value = "SPREAD";
    el("preTeam").value = "A";
    el("preOdds").value = -110;
    el("preLine").value = -3.5;
    el("preStake").value = 50;

    el("liveType").value = "SPREAD";
    el("liveTeam").value = "B";
    el("liveOdds").value = -110;
    el("liveLine").value = 7.5;
    el("drift").value = 15;

    el("liveStakeMax").value = 400;
    el("liveStakeStep").value = 1;
    setSliderConfig();
    el("liveStake").value = 50;
    update();
  });
}

fillTeams();
setSliderConfig();
hook();
update();
</script>
</body>
</html>
